Configuration: 
---- UseAdditionalOutput: True
---- UseAdditionalInput : False
---- OnlyNewUsage       : False
---- GivenExample       : 1
---- UseTypedUsage      : False
---- NewKeyWords        : 
---- OldKeyWords        : 
---- OldUsageThreashold : 0.15
---- NewUsageThreashold : 0.25
---- Validate           : True
load 5 relevant edits!
load 110 new relevant usages
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\azure-servicebus-polly
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\CalculateFunding-Common
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\captain-hook
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\library-reCaptcha
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\microservices-dotnetcore-docker-sf-k8s
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\MS.DotNetCore.App
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\ROL
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\ServiceFabricGateway
loading D:\workspace\breaking-changes\benchmark\Polly\Polly_6.1.2_7.0.0\clients\Uragano
load 8 relevant client edits!
Log: invoke synthesis engine...
Log: the size of unRolledEdits is: 7
size of new usage: 110
Log: add new usage Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
Log: add new usage Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
Log: add new usage Policy.WrapAsync(CreatePolicies().ToArray())
Log: add new usage Policy.WrapAsync(CreatePolicies().ToArray())
Log: add new usage var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: add new usage var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage policy.WrapAsync(Policy.BulkheadAsync(MaxParallelization, MaxQueuingActions))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(RetryTimes, t => RetryInterval))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(Timeout, TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowed, BreakTime))
Log: add new usage policy.WrapAsync(Policy.BulkheadAsync(MaxParallelization, MaxQueuingActions))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(RetryTimes, t => RetryInterval))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(Timeout, TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowed, BreakTime))
Log: add new usage Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
Log: add new usage Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
Log: add new usage var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: add new usage var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
Log: add new usage Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
Log: add new usage var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: add new usage var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage exceptionPolicy.WrapAsync(falseResultPolicy)
Log: add new usage exceptionPolicy.WrapAsync(falseResultPolicy)
Log: add new usage var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: add new usage var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
Log: add new usage Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
Log: add new usage Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
Log: add new usage Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
Log: add new usage fallback.WrapAsync(retry)
Log: add new usage fallback.WrapAsync(retry)
Log: add new usage Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
Log: add new usage Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
Log: add new usage Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
Log: add new usage Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option));
Log: add new usage Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option))
Log: add new usage return Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option));
Log: add new usage Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option))
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
Log: add new usage Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy)
Log: add new usage Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
Log: add new usage Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy)
Log: add new usage Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: add new usage var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: add new usage var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage retry.WrapAsync(timeoutPolicy)
Log: add new usage retry.WrapAsync(timeoutPolicy)
Log: add new usage var policy = retry.WrapAsync(timeoutPolicy);
Log: add new usage var policy = retry.WrapAsync(timeoutPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(_timeoutPolicy, _retryPolicy)
Log: add new usage Policy.WrapAsync(_timeoutPolicy, _retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy)
Log: add new usage Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy)
Log: add new usage var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: add new usage var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(otherHttpRetryPolicy, azureFunctionHttpsRetryPolicy)
Log: add new usage Policy.WrapAsync(otherHttpRetryPolicy, azureFunctionHttpsRetryPolicy)
Log: add new usage _collapserPolicy.WrapAsync(cachePolicy)
Log: add new usage _collapserPolicy.WrapAsync(cachePolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage timeout.WrapAsync(retry)
Log: add new usage timeout.WrapAsync(retry)
Log: add new usage var policies = timeout.WrapAsync(retry);
Log: add new usage var policies = timeout.WrapAsync(retry);
Log: add new usage Policy.WrapAsync(retryPolicy, circuitBreakerPolicy)
Log: add new usage Policy.WrapAsync(retryPolicy, circuitBreakerPolicy)
Log: add new usage var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: add new usage var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: add new usage Policy.WrapAsync(cachePolicy, retryPolicy)
Log: add new usage Policy.WrapAsync(cachePolicy, retryPolicy)
Log: add new usage var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: add new usage var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: add new usage Policy.WrapAsync(cachePolicy, retryPolicy)
Log: add new usage Policy.WrapAsync(cachePolicy, retryPolicy)
Log: add new usage var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: add new usage var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker)
Log: add new usage Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker)
Log: add new usage var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
Log: add new usage var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
Log: add new usage retryAfterPolicy.WrapAsync(httpRetryPolicy).WrapAsync(timeoutPolicy)
Log: add new usage retryAfterPolicy.WrapAsync(httpRetryPolicy)
Log: add new usage retryAfterPolicy.WrapAsync(httpRetryPolicy).WrapAsync(timeoutPolicy)
Log: add new usage retryAfterPolicy.WrapAsync(httpRetryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(() => asyncHttpCall.Invoke(requestMessage, cancellationToken));
Log: add new usage timeOutPolicy.WrapAsync(retryAndSleepPolicy)
Log: add new usage return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(() => asyncHttpCall.Invoke(requestMessage, cancellationToken));
Log: add new usage timeOutPolicy.WrapAsync(retryAndSleepPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker)
Log: add new usage Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker)
Log: add new usage var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
Log: add new usage var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
Log: add new usage return Policy.WrapAsync(retry, breaker);
Log: add new usage Policy.WrapAsync(retry, breaker)
Log: add new usage return Policy.WrapAsync(retry, breaker);
Log: add new usage Policy.WrapAsync(retry, breaker)
Log: add new usage policyFallBack.WrapAsync(policy)
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOut), Polly.Timeout.TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(DurationOfBreak)))
Log: add new usage policyFallBack.WrapAsync(policy)
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOut), Polly.Timeout.TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(DurationOfBreak)))
Log: add new usage Policy.WrapAsync(policy, timeOut)
Log: add new usage Policy.WrapAsync(policy, retry)
Log: add new usage Policy.WrapAsync(fallback, circuitBreaker)
Log: add new usage Policy.WrapAsync(policy, timeOut)
Log: add new usage Policy.WrapAsync(policy, retry)
Log: add new usage Policy.WrapAsync(fallback, circuitBreaker)
Log: add new usage exceptionPolicy.WrapAsync(falseResultPolicy)
Log: add new usage exceptionPolicy.WrapAsync(falseResultPolicy)
Log: add new usage var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: add new usage var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(_policyCreator(normalizeOrigin).ToArray())
Log: add new usage Policy.WrapAsync(_policyCreator(normalizeOrigin).ToArray())
Log: add new usage Policy.WrapAsync(fallback2, bulk)
Log: add new usage Policy.WrapAsync(fallback, retry, breakPolicy)
Log: add new usage Policy.WrapAsync(fallback2, bulk)
Log: add new usage Policy.WrapAsync(fallback, retry, breakPolicy)
Log: add new usage var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
Log: add new usage var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
Log: add new usage var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
Log: add new usage var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy).AsAsyncPolicy < HttpResponseMessage >()
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
Log: add new usage Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy)
Log: add new usage Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy).AsAsyncPolicy < HttpResponseMessage >()
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
Log: add new usage Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy)
Log: add new usage Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
Log: add new usage var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
Log: add new usage var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: add new usage HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
Log: add new usage HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
Log: add new usage var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: add new usage var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: add new usage Policy.WrapAsync(_asyncPolicies.ToArray())
Log: add new usage Policy.WrapAsync(_asyncPolicies.ToArray())
Log: add new usage HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
Log: add new usage HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
Log: add new usage var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: add new usage var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(async() => { var newRequestMessage = await CloneHttpRequestMessage(requestMessage).ConfigureAwait(false); return await asyncHttpCall.Invoke(newRequestMessage, cancellationToken).ConfigureAwait(false); });
Log: add new usage timeOutPolicy.WrapAsync(retryAndSleepPolicy)
Log: add new usage return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(async() => { var newRequestMessage = await CloneHttpRequestMessage(requestMessage).ConfigureAwait(false); return await asyncHttpCall.Invoke(newRequestMessage, cancellationToken).ConfigureAwait(false); });
Log: add new usage timeOutPolicy.WrapAsync(retryAndSleepPolicy)
Log: add new usage Policy.WrapAsync(fallbackPolicy, _circuitBreakerPolicy)
Log: add new usage Policy.WrapAsync(fallbackPolicy, _circuitBreakerPolicy)
Log: add new usage Policy.WrapAsync(policyRetry, policyBreak)
Log: add new usage Policy.WrapAsync(policyRetry, policyBreak)
Log: add new usage var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
Log: add new usage var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
Log: add new usage Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
Log: add new usage Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
Log: add new usage return sharedBulkhead.WrapAsync(Component.GetPolicy());
Log: add new usage sharedBulkhead.WrapAsync(Component.GetPolicy())
Log: add new usage return sharedBulkhead.WrapAsync(Component.GetPolicy());
Log: add new usage sharedBulkhead.WrapAsync(Component.GetPolicy())
Log: add new usage return circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy());
Log: add new usage circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy())
Log: add new usage return circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy());
Log: add new usage circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy())
Log: add new usage return waitAndRetryPolicy.WrapAsync(Component.GetPolicy());
Log: add new usage waitAndRetryPolicy.WrapAsync(Component.GetPolicy())
Log: add new usage return waitAndRetryPolicy.WrapAsync(Component.GetPolicy());
Log: add new usage waitAndRetryPolicy.WrapAsync(Component.GetPolicy())
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(retryPolicy, timeoutPolicy);
Log: add new usage Policy.WrapAsync(retryPolicy, timeoutPolicy)
Log: add new usage return Policy.WrapAsync(retryPolicy, timeoutPolicy);
Log: add new usage Policy.WrapAsync(retryPolicy, timeoutPolicy)
Log: add new usage policyFallBack.WrapAsync(policy)
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOutMilliseconds), TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(IsForceDowngrade ? 1 : ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)))
Log: add new usage policyFallBack.WrapAsync(policy)
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOutMilliseconds), TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(IsForceDowngrade ? 1 : ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)))
Log: add new usage Policy.WrapAsync(fallbackPolicy, retryPolicy)
Log: add new usage Policy.WrapAsync(fallbackPolicy, retryPolicy)
Log: add new usage var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
Log: add new usage var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(fallback, breaker)
Log: add new usage Policy.WrapAsync(fallback, breaker)
Log: add new usage var policy = Policy.WrapAsync(fallback, breaker);
Log: add new usage var policy = Policy.WrapAsync(fallback, breaker);
Log: add new usage Policy.WrapAsync(retryPolicy, chaosPolicy)
Log: add new usage Policy.WrapAsync(retryPolicy, chaosPolicy)
Log: add new usage var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
Log: add new usage var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
Log: add new usage _unauthorizedPolicy.WrapAsync(_timeoutPolicy)
Log: add new usage _unauthorizedPolicy.WrapAsync(_timeoutPolicy)
Log: add new usage _fallbackPolicy.WrapAsync(_retryPolicy)
Log: add new usage _fallbackPolicy.WrapAsync(_retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy))
Log: add new usage Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)
Log: add new usage fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy))
Log: add new usage Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
Log: add new usage Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
Log: add new usage Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
Log: add new usage Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage RetryHelper.WrapAsync(downloadImageService.GetImage())
Log: add new usage RetryHelper.WrapAsync(downloadImageService.GetImage())
Log: add new usage RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachCelebrity.Name, this.settingsService.EntitySearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachCelebrity.Name, this.settingsService.EntitySearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.imageSearchService.GetSimilarImagesAsync(image, Settings.Settings.ImageSearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.imageSearchService.GetSimilarImagesAsync(image, Settings.Settings.ImageSearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachLandmark.Name, this.settingsService.EntitySearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachLandmark.Name, this.settingsService.EntitySearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.ocrService.RecognizeHandWritingTextRequest(image, this.settingsService.TextRecognitionAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.ocrService.RecognizeHandWritingTextRequest(image, this.settingsService.TextRecognitionAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.translatorService.Translate(this.Text, from, to, this.settingsService.TranslatorAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.translatorService.Translate(this.Text, from, to, this.settingsService.TranslatorAPIKey))
Log: add new usage return RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey));
Log: add new usage RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey))
Log: add new usage return RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey));
Log: add new usage RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.luisService.Proccess(this.settingsService.LuisAPPID, q : this.text, timezoneOffset : "0", verbose : "false", spellCheck : "false", staging : "false", apiKey : this.settingsService.LuisAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.luisService.Proccess(this.settingsService.LuisAPPID, q : this.text, timezoneOffset : "0", verbose : "false", spellCheck : "false", staging : "false", apiKey : this.settingsService.LuisAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.productsService.GetSimilar(imageStream, Settings.Settings.ImageSearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.productsService.GetSimilar(imageStream, Settings.Settings.ImageSearchAPIKey))
Log: add new usage Forms.Common.RetryHelper.WrapAsync(this.service.RecognizePrintedText(image, APIKeys.ImageAnalysisAndTextRecognitionAPIKey))
Log: add new usage Forms.Common.RetryHelper.WrapAsync(this.service.RecognizePrintedText(image, APIKeys.ImageAnalysisAndTextRecognitionAPIKey))
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy()).WrapAsync(SimplePolicies.GetTimeoutPolicy())
Log: add new usage SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy())
Log: add new usage SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy()).WrapAsync(SimplePolicies.GetTimeoutPolicy())
Log: add new usage SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy())
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallBackpolicy.WrapAsync(policy)
Log: add new usage fallBackpolicy.WrapAsync(policy)
Log: add new usage var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: add new usage var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: add new usage fallBackpolicy.WrapAsync(policy)
Log: add new usage fallBackpolicy.WrapAsync(policy)
Log: add new usage var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: add new usage var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: add old usage fallBackPolicy.WrapAsync(retryPolicy)
Log: add old usage fallBackPolicy.WrapAsync(retryPolicy)
Log: add old usage fallBackPolicy.WrapAsync(retryPolicy)
Log: add old usage fallBackPolicy.WrapAsync(retryPolicy)
Log: add old usage Policy.WrapAsync(policies.ToArray())
Log: add old usage Policy.WrapAsync(policies.ToArray())
PolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
PolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Abstracted PolicyWrap =.WrapAsync;
PolicyWrap =.WrapAsync; : LocalDeclarationStatement : 
PolicyWrap =.WrapAsync : VariableDeclaration : LocalDeclarationStatement
PolicyWrap : IdentifierName : VariableDeclaration
PolicyWrap : IdentifierToken : IdentifierName
=.WrapAsync : VariableDeclarator : VariableDeclaration
=.WrapAsync : EqualsValueClause : VariableDeclarator
= : EqualsToken : EqualsValueClause
.WrapAsync : InvocationExpression : EqualsValueClause
.WrapAsync : SimpleMemberAccessExpression : InvocationExpression
. : DotToken : SimpleMemberAccessExpression
WrapAsync : IdentifierName : SimpleMemberAccessExpression
WrapAsync : IdentifierToken : IdentifierName
 : ArgumentList : InvocationExpression
; : SemicolonToken : LocalDeclarationStatement
Abstracted PolicyWrap =.WrapAsync;
PolicyWrap =.WrapAsync; : LocalDeclarationStatement : 
PolicyWrap =.WrapAsync : VariableDeclaration : LocalDeclarationStatement
PolicyWrap : IdentifierName : VariableDeclaration
PolicyWrap : IdentifierToken : IdentifierName
=.WrapAsync : VariableDeclarator : VariableDeclaration
=.WrapAsync : EqualsValueClause : VariableDeclarator
= : EqualsToken : EqualsValueClause
.WrapAsync : InvocationExpression : EqualsValueClause
.WrapAsync : SimpleMemberAccessExpression : InvocationExpression
. : DotToken : SimpleMemberAccessExpression
WrapAsync : IdentifierName : SimpleMemberAccessExpression
WrapAsync : IdentifierToken : IdentifierName
 : ArgumentList : InvocationExpression
; : SemicolonToken : LocalDeclarationStatement
Dis: 0

Log: add old usage PolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
PolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
PolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Abstracted PolicyWrap =.WrapAsync;
PolicyWrap =.WrapAsync; : LocalDeclarationStatement : 
PolicyWrap =.WrapAsync : VariableDeclaration : LocalDeclarationStatement
PolicyWrap : IdentifierName : VariableDeclaration
PolicyWrap : IdentifierToken : IdentifierName
=.WrapAsync : VariableDeclarator : VariableDeclaration
=.WrapAsync : EqualsValueClause : VariableDeclarator
= : EqualsToken : EqualsValueClause
.WrapAsync : InvocationExpression : EqualsValueClause
.WrapAsync : SimpleMemberAccessExpression : InvocationExpression
. : DotToken : SimpleMemberAccessExpression
WrapAsync : IdentifierName : SimpleMemberAccessExpression
WrapAsync : IdentifierToken : IdentifierName
 : ArgumentList : InvocationExpression
; : SemicolonToken : LocalDeclarationStatement
Abstracted PolicyWrap =.WrapAsync;
PolicyWrap =.WrapAsync; : LocalDeclarationStatement : 
PolicyWrap =.WrapAsync : VariableDeclaration : LocalDeclarationStatement
PolicyWrap : GenericName : VariableDeclaration
PolicyWrap : IdentifierToken : GenericName
 : TypeArgumentList : GenericName
=.WrapAsync : VariableDeclarator : VariableDeclaration
=.WrapAsync : EqualsValueClause : VariableDeclarator
= : EqualsToken : EqualsValueClause
.WrapAsync : InvocationExpression : EqualsValueClause
.WrapAsync : SimpleMemberAccessExpression : InvocationExpression
. : DotToken : SimpleMemberAccessExpression
WrapAsync : IdentifierName : SimpleMemberAccessExpression
WrapAsync : IdentifierToken : IdentifierName
 : ArgumentList : InvocationExpression
; : SemicolonToken : LocalDeclarationStatement
Dis: 0.07692307

Log: add old usage PolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
Log: add old usage Policy.WrapAsync(policies.ToArray())
Log: add old usage Policy.WrapAsync(policies.ToArray())
Log: add old usage Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
Log: add old usage Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
Log: add old usage Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
Log: add old usage Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
Log: add old usage policy.WrapAsync(Policy.TimeoutAsync(serviceCircuitBreakerOptions.Timeout, TimeoutStrategy.Pessimistic, async(ctx, ts, task, ex) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnTimeOut(route, service.MethodInfo, ex); }))
Log: add old usage policy.WrapAsync(Policy.Handle < Exception >().RetryAsync(serviceCircuitBreakerOptions.Retry, async(ex, times) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRetry(route, service.MethodInfo, ex, times); }))
Log: add old usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
Log: add old usage policy.WrapAsync(Policy.TimeoutAsync(serviceCircuitBreakerOptions.Timeout, TimeoutStrategy.Pessimistic, async(ctx, ts, task, ex) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnTimeOut(route, service.MethodInfo, ex); }))
Log: add old usage policy.WrapAsync(Policy.Handle < Exception >().RetryAsync(serviceCircuitBreakerOptions.Retry, async(ex, times) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRetry(route, service.MethodInfo, ex, times); }))
Log: add old usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
Log: add old usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
Log: add old usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
Log: ============== Cluster start ==============
- return ((Policy)outerPolicy).WrapAsync(innerPolicy);
----------------
+ return ((AsyncPolicy)outerPolicy).WrapAsync(innerPolicy);

new usages: return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
new usages: return Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option));
new usages: return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(() => asyncHttpCall.Invoke(requestMessage, cancellationToken));
new usages: return Policy.WrapAsync(retry, breaker);
new usages: return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(async() => { var newRequestMessage = await CloneHttpRequestMessage(requestMessage).ConfigureAwait(false); return await asyncHttpCall.Invoke(newRequestMessage, cancellationToken).ConfigureAwait(false); });
new usages: return sharedBulkhead.WrapAsync(Component.GetPolicy());
new usages: return circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy());
new usages: return waitAndRetryPolicy.WrapAsync(Component.GetPolicy());
new usages: return Policy.WrapAsync(retryPolicy, timeoutPolicy);
new usages: return RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey));
============= Cluster end ==============

Log: ============== Cluster start ==============
((Policy) outerPolicy).WrapAsync(innerPolicy)
----------------
((AsyncPolicy) outerPolicy).WrapAsync(innerPolicy)

new usages: Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
new usages: Policy.WrapAsync(CreatePolicies().ToArray())
new usages: Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
new usages: policy.WrapAsync(Policy.BulkheadAsync(MaxParallelization, MaxQueuingActions))
new usages: policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(RetryTimes, t => RetryInterval))
new usages: policy.WrapAsync(Policy.TimeoutAsync(Timeout, TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowed, BreakTime))
new usages: Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
new usages: exceptionPolicy.WrapAsync(falseResultPolicy)
new usages: Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
new usages: Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
new usages: fallback.WrapAsync(retry)
new usages: Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option))
new usages: Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
new usages: Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy)
new usages: Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
new usages: fallbackPolicy.WrapAsync(retryPolicy)
new usages: retry.WrapAsync(timeoutPolicy)
new usages: Policy.WrapAsync(_timeoutPolicy, _retryPolicy)
new usages: Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy)
new usages: Policy.WrapAsync(otherHttpRetryPolicy, azureFunctionHttpsRetryPolicy)
new usages: _collapserPolicy.WrapAsync(cachePolicy)
new usages: timeout.WrapAsync(retry)
new usages: Policy.WrapAsync(retryPolicy, circuitBreakerPolicy)
new usages: Policy.WrapAsync(cachePolicy, retryPolicy)
new usages: Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker)
new usages: retryAfterPolicy.WrapAsync(httpRetryPolicy).WrapAsync(timeoutPolicy)
new usages: retryAfterPolicy.WrapAsync(httpRetryPolicy)
new usages: timeOutPolicy.WrapAsync(retryAndSleepPolicy)
new usages: Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker)
new usages: Policy.WrapAsync(retry, breaker)
new usages: policyFallBack.WrapAsync(policy)
new usages: policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
new usages: policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOut), Polly.Timeout.TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(DurationOfBreak)))
new usages: Policy.WrapAsync(policy, timeOut)
new usages: Policy.WrapAsync(policy, retry)
new usages: Policy.WrapAsync(fallback, circuitBreaker)
new usages: Policy.WrapAsync(_policyCreator(normalizeOrigin).ToArray())
new usages: Policy.WrapAsync(fallback2, bulk)
new usages: Policy.WrapAsync(fallback, retry, breakPolicy)
new usages: Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy).AsAsyncPolicy < HttpResponseMessage >()
new usages: Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy)
new usages: HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
new usages: Policy.WrapAsync(_asyncPolicies.ToArray())
new usages: Policy.WrapAsync(fallbackPolicy, _circuitBreakerPolicy)
new usages: Policy.WrapAsync(policyRetry, policyBreak)
new usages: sharedBulkhead.WrapAsync(Component.GetPolicy())
new usages: circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy())
new usages: waitAndRetryPolicy.WrapAsync(Component.GetPolicy())
new usages: Policy.WrapAsync(retryPolicy, timeoutPolicy)
new usages: policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOutMilliseconds), TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(IsForceDowngrade ? 1 : ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)))
new usages: Policy.WrapAsync(fallbackPolicy, retryPolicy)
new usages: Policy.WrapAsync(fallback, breaker)
new usages: Policy.WrapAsync(retryPolicy, chaosPolicy)
new usages: _unauthorizedPolicy.WrapAsync(_timeoutPolicy)
new usages: _fallbackPolicy.WrapAsync(_retryPolicy)
new usages: fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy))
new usages: Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)
new usages: Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
new usages: RetryHelper.WrapAsync(downloadImageService.GetImage())
new usages: RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachCelebrity.Name, this.settingsService.EntitySearchAPIKey))
new usages: RetryHelper.WrapAsync(this.imageSearchService.GetSimilarImagesAsync(image, Settings.Settings.ImageSearchAPIKey))
new usages: RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachLandmark.Name, this.settingsService.EntitySearchAPIKey))
new usages: RetryHelper.WrapAsync(this.ocrService.RecognizeHandWritingTextRequest(image, this.settingsService.TextRecognitionAPIKey))
new usages: RetryHelper.WrapAsync(this.translatorService.Translate(this.Text, from, to, this.settingsService.TranslatorAPIKey))
new usages: RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey))
new usages: RetryHelper.WrapAsync(this.luisService.Proccess(this.settingsService.LuisAPPID, q : this.text, timezoneOffset : "0", verbose : "false", spellCheck : "false", staging : "false", apiKey : this.settingsService.LuisAPIKey))
new usages: RetryHelper.WrapAsync(this.productsService.GetSimilar(imageStream, Settings.Settings.ImageSearchAPIKey))
new usages: Forms.Common.RetryHelper.WrapAsync(this.service.RecognizePrintedText(image, APIKeys.ImageAnalysisAndTextRecognitionAPIKey))
new usages: SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy()).WrapAsync(SimplePolicies.GetTimeoutPolicy())
new usages: SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy())
new usages: fallBackpolicy.WrapAsync(policy)
old usages: fallBackPolicy.WrapAsync(retryPolicy)
old usages: fallBackPolicy.WrapAsync(retryPolicy)
old usages: Policy.WrapAsync(policies.ToArray())
old usages: Policy.WrapAsync(policies.ToArray())
old usages: Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
old usages: Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
old usages: policy.WrapAsync(Policy.TimeoutAsync(serviceCircuitBreakerOptions.Timeout, TimeoutStrategy.Pessimistic, async(ctx, ts, task, ex) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnTimeOut(route, service.MethodInfo, ex); }))
old usages: policy.WrapAsync(Policy.Handle < Exception >().RetryAsync(serviceCircuitBreakerOptions.Retry, async(ex, times) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRetry(route, service.MethodInfo, ex, times); }))
old usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
old usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
============= Cluster end ==============

Log: Input to synthesize the program:
Log: ((Policy) outerPolicy).WrapAsync(innerPolicy)
Log: ---------------------
Log: ((AsyncPolicy) outerPolicy).WrapAsync(innerPolicy)
Log: old usage is fallBackPolicy.WrapAsync(retryPolicy)
Log: predict is null
Log: old usage is fallBackPolicy.WrapAsync(retryPolicy)
Log: predict is null
Log: old usage is Policy.WrapAsync(policies.ToArray())
Log: predict is null
Log: old usage is Policy.WrapAsync(policies.ToArray())
Log: predict is null
Log: old usage is Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
Log: predict is null
Log: old usage is Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
Log: predict is null
Log: old usage is policy.WrapAsync(Policy.TimeoutAsync(serviceCircuitBreakerOptions.Timeout, TimeoutStrategy.Pessimistic, async(ctx, ts, task, ex) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnTimeOut(route, service.MethodInfo, ex); }))
Log: predict is null
Log: old usage is policy.WrapAsync(Policy.Handle < Exception >().RetryAsync(serviceCircuitBreakerOptions.Retry, async(ex, times) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRetry(route, service.MethodInfo, ex, times); }))
Log: predict is null
Log: old usage is policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
Log: predict is null
Log: old usage is policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
Log: predict is null
Log: ============== Cluster start ==============
- return ((Policy<TResult>)outerPolicy).WrapAsync(innerPolicy);
----------------
+ return ((AsyncPolicy<TResult>)outerPolicy).WrapAsync(innerPolicy);

new usages: return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
new usages: return Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option));
new usages: return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(() => asyncHttpCall.Invoke(requestMessage, cancellationToken));
new usages: return Policy.WrapAsync(retry, breaker);
new usages: return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(async() => { var newRequestMessage = await CloneHttpRequestMessage(requestMessage).ConfigureAwait(false); return await asyncHttpCall.Invoke(newRequestMessage, cancellationToken).ConfigureAwait(false); });
new usages: return sharedBulkhead.WrapAsync(Component.GetPolicy());
new usages: return circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy());
new usages: return waitAndRetryPolicy.WrapAsync(Component.GetPolicy());
new usages: return Policy.WrapAsync(retryPolicy, timeoutPolicy);
new usages: return RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey));
============= Cluster end ==============

Log: ============== Cluster start ==============
((Policy < TResult >) outerPolicy).WrapAsync(innerPolicy)
----------------
((AsyncPolicy < TResult >) outerPolicy).WrapAsync(innerPolicy)

new usages: Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
new usages: Policy.WrapAsync(CreatePolicies().ToArray())
new usages: Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
new usages: policy.WrapAsync(Policy.BulkheadAsync(MaxParallelization, MaxQueuingActions))
new usages: policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(RetryTimes, t => RetryInterval))
new usages: policy.WrapAsync(Policy.TimeoutAsync(Timeout, TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowed, BreakTime))
new usages: Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
new usages: exceptionPolicy.WrapAsync(falseResultPolicy)
new usages: Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
new usages: Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
new usages: fallback.WrapAsync(retry)
new usages: Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option))
new usages: Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
new usages: Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy)
new usages: Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
new usages: fallbackPolicy.WrapAsync(retryPolicy)
new usages: retry.WrapAsync(timeoutPolicy)
new usages: Policy.WrapAsync(_timeoutPolicy, _retryPolicy)
new usages: Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy)
new usages: Policy.WrapAsync(otherHttpRetryPolicy, azureFunctionHttpsRetryPolicy)
new usages: _collapserPolicy.WrapAsync(cachePolicy)
new usages: timeout.WrapAsync(retry)
new usages: Policy.WrapAsync(retryPolicy, circuitBreakerPolicy)
new usages: Policy.WrapAsync(cachePolicy, retryPolicy)
new usages: Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker)
new usages: retryAfterPolicy.WrapAsync(httpRetryPolicy).WrapAsync(timeoutPolicy)
new usages: retryAfterPolicy.WrapAsync(httpRetryPolicy)
new usages: timeOutPolicy.WrapAsync(retryAndSleepPolicy)
new usages: Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker)
new usages: Policy.WrapAsync(retry, breaker)
new usages: policyFallBack.WrapAsync(policy)
new usages: policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
new usages: policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOut), Polly.Timeout.TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(DurationOfBreak)))
new usages: Policy.WrapAsync(policy, timeOut)
new usages: Policy.WrapAsync(policy, retry)
new usages: Policy.WrapAsync(fallback, circuitBreaker)
new usages: Policy.WrapAsync(_policyCreator(normalizeOrigin).ToArray())
new usages: Policy.WrapAsync(fallback2, bulk)
new usages: Policy.WrapAsync(fallback, retry, breakPolicy)
new usages: Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy).AsAsyncPolicy < HttpResponseMessage >()
new usages: Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy)
new usages: HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
new usages: Policy.WrapAsync(_asyncPolicies.ToArray())
new usages: Policy.WrapAsync(fallbackPolicy, _circuitBreakerPolicy)
new usages: Policy.WrapAsync(policyRetry, policyBreak)
new usages: sharedBulkhead.WrapAsync(Component.GetPolicy())
new usages: circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy())
new usages: waitAndRetryPolicy.WrapAsync(Component.GetPolicy())
new usages: Policy.WrapAsync(retryPolicy, timeoutPolicy)
new usages: policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOutMilliseconds), TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(IsForceDowngrade ? 1 : ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)))
new usages: Policy.WrapAsync(fallbackPolicy, retryPolicy)
new usages: Policy.WrapAsync(fallback, breaker)
new usages: Policy.WrapAsync(retryPolicy, chaosPolicy)
new usages: _unauthorizedPolicy.WrapAsync(_timeoutPolicy)
new usages: _fallbackPolicy.WrapAsync(_retryPolicy)
new usages: fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy))
new usages: Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)
new usages: Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
new usages: RetryHelper.WrapAsync(downloadImageService.GetImage())
new usages: RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachCelebrity.Name, this.settingsService.EntitySearchAPIKey))
new usages: RetryHelper.WrapAsync(this.imageSearchService.GetSimilarImagesAsync(image, Settings.Settings.ImageSearchAPIKey))
new usages: RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachLandmark.Name, this.settingsService.EntitySearchAPIKey))
new usages: RetryHelper.WrapAsync(this.ocrService.RecognizeHandWritingTextRequest(image, this.settingsService.TextRecognitionAPIKey))
new usages: RetryHelper.WrapAsync(this.translatorService.Translate(this.Text, from, to, this.settingsService.TranslatorAPIKey))
new usages: RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey))
new usages: RetryHelper.WrapAsync(this.luisService.Proccess(this.settingsService.LuisAPPID, q : this.text, timezoneOffset : "0", verbose : "false", spellCheck : "false", staging : "false", apiKey : this.settingsService.LuisAPIKey))
new usages: RetryHelper.WrapAsync(this.productsService.GetSimilar(imageStream, Settings.Settings.ImageSearchAPIKey))
new usages: Forms.Common.RetryHelper.WrapAsync(this.service.RecognizePrintedText(image, APIKeys.ImageAnalysisAndTextRecognitionAPIKey))
new usages: SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy()).WrapAsync(SimplePolicies.GetTimeoutPolicy())
new usages: SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy())
new usages: fallBackpolicy.WrapAsync(policy)
old usages: fallBackPolicy.WrapAsync(retryPolicy)
old usages: fallBackPolicy.WrapAsync(retryPolicy)
old usages: Policy.WrapAsync(policies.ToArray())
old usages: Policy.WrapAsync(policies.ToArray())
old usages: Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
old usages: Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
old usages: policy.WrapAsync(Policy.TimeoutAsync(serviceCircuitBreakerOptions.Timeout, TimeoutStrategy.Pessimistic, async(ctx, ts, task, ex) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnTimeOut(route, service.MethodInfo, ex); }))
old usages: policy.WrapAsync(Policy.Handle < Exception >().RetryAsync(serviceCircuitBreakerOptions.Retry, async(ex, times) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRetry(route, service.MethodInfo, ex, times); }))
old usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
old usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
============= Cluster end ==============

Log: Input to synthesize the program:
Log: ((Policy < TResult >) outerPolicy).WrapAsync(innerPolicy)
Log: ---------------------
Log: ((AsyncPolicy < TResult >) outerPolicy).WrapAsync(innerPolicy)
Log: old usage is fallBackPolicy.WrapAsync(retryPolicy)
Log: predict is null
Log: old usage is fallBackPolicy.WrapAsync(retryPolicy)
Log: predict is null
Log: old usage is Policy.WrapAsync(policies.ToArray())
Log: predict is null
Log: old usage is Policy.WrapAsync(policies.ToArray())
Log: predict is null
Log: old usage is Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
Log: predict is null
Log: old usage is Policy.WrapAsync((IAsyncPolicy[]) Enumerable.ToArray < Policy >(this._policyCreator(text)))
Log: predict is null
Log: old usage is policy.WrapAsync(Policy.TimeoutAsync(serviceCircuitBreakerOptions.Timeout, TimeoutStrategy.Pessimistic, async(ctx, ts, task, ex) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnTimeOut(route, service.MethodInfo, ex); }))
Log: predict is null
Log: old usage is policy.WrapAsync(Policy.Handle < Exception >().RetryAsync(serviceCircuitBreakerOptions.Retry, async(ex, times) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRetry(route, service.MethodInfo, ex, times); }))
Log: predict is null
Log: old usage is policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
Log: predict is null
Log: old usage is policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(serviceCircuitBreakerOptions.ExceptionsAllowedBeforeBreaking, serviceCircuitBreakerOptions.DurationOfBreak, async(ex, state, ts, ctx) => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnBreak(route, service.MethodInfo, ex, ts); }, async ctx => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnRest(route, service.MethodInfo); }, async() => { if(circuitBreakerEvent != null) await circuitBreakerEvent.OnHalfOpen(route, service.MethodInfo); }))
Log: predict is null
Log: ============== Cluster start ==============
PolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
----------------
AsyncPolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);

new usages: var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
new usages: var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
new usages: var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
new usages: var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
new usages: var policy = retry.WrapAsync(timeoutPolicy);
new usages: var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
new usages: var policies = timeout.WrapAsync(retry);
new usages: var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
new usages: var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
new usages: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
new usages: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
new usages: var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
new usages: var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
new usages: var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
new usages: var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
new usages: var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
new usages: var policy = Policy.WrapAsync(fallback, breaker);
new usages: var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
new usages: var retryWithFallback = fallBackpolicy.WrapAsync(policy);
old usages: PolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
============= Cluster end ==============

Log: Input to synthesize the program:
Log: PolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Log: ---------------------
Log: AsyncPolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Log: old usage is PolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
Log: predict is AsyncPolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
Log: ============== Cluster start ==============
PolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
----------------
AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);

PolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
----------------
AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);

new usages: var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
new usages: var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
new usages: var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
new usages: var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
new usages: var policy = retry.WrapAsync(timeoutPolicy);
new usages: var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
new usages: var policies = timeout.WrapAsync(retry);
new usages: var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
new usages: var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
new usages: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
new usages: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
new usages: var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
new usages: var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
new usages: var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
new usages: var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
new usages: var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
new usages: var policy = Policy.WrapAsync(fallback, breaker);
new usages: var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
new usages: var retryWithFallback = fallBackpolicy.WrapAsync(policy);
old usages: PolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
============= Cluster end ==============

Log: Input to synthesize the program:
Log: PolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Log: ---------------------
Log: AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Log: predict is AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
Log: output  is AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
Log: ----------------------------------------------------
Log: old usage is PolicyWrap policyWrap = Policy.WrapAsync(policies.ToArray());
Log: predict is null
total correct cases : 1 totalTestCases 1 Successful rate is 1
The successful rate for transforming old usages: 1 / 8
