load 3 relevant edits!
load 867 old relevant usages
load 592 new relevant usages
invoke synthesis engine...
old usage sise 867, new usage size 592
the size of unRolledEdits is: 3
size of new usage: 592
add new usage var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { });
add new usage var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
add new usage var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
add new usage var waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
add new usage var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
add new usage var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 983 || x.Number == 978).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { _logger.LogInformation(exception, "Open Connection - DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var policy = Policy.HandleResult < LockLeaseResult >(lockLeaseResult => ! lockLeaseResult.Ok).WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(retryAfter));
add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { });
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(NumberOfRetries, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { _logger.LogError($"Could not replicate - exception {exception.Message}"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var falseResultPolicy = Policy.HandleResult(false).WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry());
add new usage var exceptionPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode ==(HttpStatusCode) 429).WaitAndRetryAsync(retryCount : MaxRetries, sleepDurationProvider :(retryCount, response, context) => { return response.Result ?.Headers.RetryAfter.Delta.Value ?? TimeSpan.FromSeconds(30 * retryCount); }, onRetryAsync : async(response, timespan, retryCount, context) => { await Console.Out.WriteLineAsync($"{Environment.NewLine}Waiting {timespan} before retrying (attemp #{retryCount}/{MaxRetries})..."); });
add new usage var retryPolicy = Policy.Handle < AdalServiceException >().WaitAndRetryAsync(MAX_TOKEN_RETRY_ATTEMPTS, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.NotFound).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
add new usage AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
add new usage var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var policy = Policy.Handle < Exception >(e => { Console.WriteLine("Tentando obter Token"); return true; }).WaitAndRetryAsync(3, i => TimeSpan.FromTicks(5));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
add new usage var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
add new usage var policy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(x => x.StatusCode == HttpStatusCode.BadRequest).WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
add new usage var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
add new usage var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < SoapException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => Logger.Error(exception, "?????? ??? ??????? ??????. ???: {code}. ?????????: {message}. ????? ???????? ?? ????????? ???????: {timeSpan}. ???????: {retryCount}", exception.HResult, exception.Message, timeSpan, retryCount));
add new usage var waitAndRetryPolicy = Policy.HandleResult < DeliveryStatus >(status => status != DeliveryStatus.Delivered).WaitAndRetryAsync(11, retryAttempt => TimeSpan.FromSeconds(10 * retryAttempt),(result, timeSpan, retryCount, context) => Logger.Info("????????? {messageId} ??? ?????? {appId} ??????? {userName} ?? ??????????. ??????? ?????? ???????? {status}. ????? ???????? ?? ????????? ???????: {timeSpan}. ???????: {retryCount}", messageId, applicationId, userName ?? "",((SmsDeliveryStatus) result.Result).GetDescription(), timeSpan, retryCount));
add new usage var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(result, timeSpan, retryCount, context) => Logger.Error(result.Exception, "?????? ? ??????? ?????????? ????????. ???: {statusCode}. ????? ???????? ?? ????????? ???????: {timeSpan}. ???????: {retryCount} {request}", result.Result.StatusCode, timeSpan, retryCount, requestContent));
add new usage var waitAndRetryPolicy = Policy.HandleResult < ClientValidationRequest >(result => result ?.Result ==(int) ClientValidationResult.Requested).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < bool >(result => result == false).WaitAndRetryAsync(RetryCount, i => TimeSpan.FromSeconds(WaitSecondsBeforeRetry));
add new usage AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
add new usage var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retriesCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan) => { logger.LogError(exception, $"Operation failed, retrying in {timeSpan.Seconds} seconds"); });
add new usage var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryFailedUserPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var policy = Policy.Handle < ResponseException >().Or < ConnectionPoolBusyException >().Or < ServerUnavailableException >().WaitAndRetryAsync(retryCount : 10, sleepDurationProvider :(attempt, exception, context) => { if(exception is ResponseException responseException && responseException.CosmosDbStatusCode() == RetryAfterStatusCode) { return TimeSpan.FromSeconds(5 + 5 * attempt * _jitterer.NextDouble()); } _logger.LogInformation($"Exception {exception.GetType()}. Retry immediately"); return TimeSpan.Zero; }, onRetryAsync :(exception, waitTime, attempt, _) => { totalWaitTime = totalWaitTime.Add(waitTime); retryCount = attempt; if(exception is ResponseException responseException) { var exceptionRu = CosmosResponse.ParseRequestCharge(responseException.StatusAttributes); totalRu += exceptionRu; _logger.LogInformation($"ResponseException cost {exceptionRu}RU"); } if(exception is ConnectionPoolBusyException || exception is ServerUnavailableException) { _logger.LogInformation($"Resetting the GremlinClient after experiencing an '{exception.GetType()}'"); _factory.ClearGraphClient(); } return Task.CompletedTask; });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryFailedUserPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolice = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add new usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxtrys, x => seconds);
add new usage var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.GatewayTimeout || msg.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
add new usage var policy = Policy.Handle < HttpRequestException >().Or < OperationCanceledException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(delayAfterFailure));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(10));
add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(policyConfigs.RetryCount, _ => TimeSpan.FromMilliseconds(policyConfigs.RetryDelayInMs));
add new usage var httpRetryPolicy = Policy.Handle < HttpRequestException >().Or < TaskCanceledException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(RetryRequired).WaitAndRetryAsync(GetBackOff(maxRetries));
add new usage var retryAfterPolicy = Policy.HandleResult < HttpResponseMessage >(ContainsRetryAfterHeader).WaitAndRetryAsync(maxRetries, sleepDurationProvider,(outcome, timespan, retryCount, context) => Task.CompletedTask);
add new usage var retryPolicy = HandleResult().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount, retryAttempt => retryDelay);
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
add new usage AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask; });
add new usage var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask; });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retry = Policy.Handle < Exception >().WaitAndRetryAsync(Backoff.LinearBackoff(TimeSpan.FromSeconds(settings.RetryInitialDelaySeconds), settings.RetryCount),(exception, span, retryCount, context) => { logger.LogError(exception, "{@EventType} {@Realm} {@TimeSpan} {@retryCount}", "Retry", description, span, retryCount); });
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(exception, timeSpan, retryCount, context) => { });
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
add new usage var falseResultPolicy = Policy.HandleResult(false).WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry());
add new usage var exceptionPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxtrys, x => seconds);
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage IAsyncPolicy < HttpResponseMessage > policy = Policy.Handle < SocketException >().OrTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
add new usage var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
add new usage var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var retry = Policy < HttpResponseMessage >.Handle < Exception >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var policy = Policy.Handle < InvalidOperationException >().Or < Exception >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); });
add new usage var policy = Policy.Handle < InvalidOperationException >().Or < Exception >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
add new usage AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask.ConfigureAwait(false); });
add new usage var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask.ConfigureAwait(false); });
add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
add new usage var policyRetry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(3, retryTimespan => TimeSpan.FromSeconds(Math.Pow(2, retryTimespan)),(exception, timespan, retryCount, context) => { var msg = $"? {retryCount} ??????? " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); });
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(e => HttpStatusCodeWorthRetry.ToList().Contains((int) e.StatusCode)).WaitAndRetryAsync(MaxRetryCount, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => PolicyLog($"API is throttling our requests automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"));
add new usage var policy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000));
add new usage var policy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000));
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
add new usage AsyncRetryPolicy retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var polly = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, pause => TimeSpan.FromSeconds(5));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(_appSettings.RetryAttempt, retryAttempt => TimeSpan.FromMilliseconds(3000));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolicy = Policy.HandleResult < IRestResponse >(x => FindWarning(x) is null && x.StatusCode != HttpStatusCode.NotFound && x.StatusCode != HttpStatusCode.Unauthorized && x.StatusCode != HttpStatusCode.Conflict && x.StatusCode != HttpStatusCode.BadRequest && x.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(retryNumber, retryAttempt => TimeSpan.FromSeconds(retrySleepSeconds));
add new usage var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Trying for the {retryCount} time!"); Console.ForegroundColor = ConsoleColor.White; });
add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
add new usage var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
add new usage var retryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(1),(result, span, retryCount, ctx) => { Console.WriteLine($"Retrying({retryCount})..."); });
add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
add new usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < Exception >().OrResult < HttpResponseMessage >(res => { return res.StatusCode != System.Net.HttpStatusCode.OK; }).WaitAndRetryAsync(sleepDurations : new[] { TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(200), TimeSpan.FromMilliseconds(300) }, onRetry :(exception, ts, context) => { Console.WriteLine($"polly.retry:exMsg={exception.Exception ?.Message}, {ts.Minutes * 60 + ts.Seconds}"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryWaitPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
add new usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
add new usage var retryPolicy = Policy.Handle < Exception >((ex) => { logger.Log(LogSeverity.Error,(ex.InnerException != null) ? ex.InnerException.Message : ex.Message + "\r\n GetTrendingStocks retry FAILURE"); return !(ex is Polly.CircuitBreaker.BrokenCircuitException); }).WaitAndRetryAsync(_retryCount, x => TimeSpan.FromMilliseconds(_sleepTimeAfterFail));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var retryPolice = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
add new usage var policy = Policy.Handle < SentNotificationException >().WaitAndRetryAsync(_maxRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(3, retryAttempt)));
add new usage var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
add new usage var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r =>(int) r.StatusCode == 429).WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add new usage var retryPolicy = Policy.Handle < System.Net.Sockets.SocketException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
add old usage var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
add old usage RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
add old usage RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
add old usage var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
add old usage IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
add old usage AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
add old usage Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add old usage Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
add old usage var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}????,??????!\r\n{1}", strFileName, exception.Message)); });
add old usage var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"??[{downloadUrl}?,????,????????]", Category.Warn, Priority.High); });
add old usage Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
add old usage var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
add old usage Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
============== Cluster start ==============
- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => contextData = context);
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => contextData = context);

- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => capturedContext = context);
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => capturedContext = context);

- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds()
                },
                (_, __, context) => contextValue = context["key"].ToString());
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds()
                },
                (_, __, context) => contextValue = context["key"].ToString());

new usages: var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
new usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { });
new usages: var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
new usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
new usages: var waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
new usages: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
new usages: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
new usages: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 983 || x.Number == 978).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { _logger.LogInformation(exception, "Open Connection - DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
new usages: var policy = Policy.HandleResult < LockLeaseResult >(lockLeaseResult => ! lockLeaseResult.Ok).WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(retryAfter));
new usages: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { });
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(NumberOfRetries, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { _logger.LogError($"Could not replicate - exception {exception.Message}"); });
new usages: var falseResultPolicy = Policy.HandleResult(false).WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry());
new usages: var exceptionPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
new usages: var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode ==(HttpStatusCode) 429).WaitAndRetryAsync(retryCount : MaxRetries, sleepDurationProvider :(retryCount, response, context) => { return response.Result ?.Headers.RetryAfter.Delta.Value ?? TimeSpan.FromSeconds(30 * retryCount); }, onRetryAsync : async(response, timespan, retryCount, context) => { await Console.Out.WriteLineAsync($"{Environment.NewLine}Waiting {timespan} before retrying (attemp #{retryCount}/{MaxRetries})..."); });
new usages: var retryPolicy = Policy.Handle < AdalServiceException >().WaitAndRetryAsync(MAX_TOKEN_RETRY_ATTEMPTS, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.NotFound).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
new usages: AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
new usages: var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var policy = Policy.Handle < Exception >(e => { Console.WriteLine("Tentando obter Token"); return true; }).WaitAndRetryAsync(3, i => TimeSpan.FromTicks(5));
new usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
new usages: var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
new usages: var policy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(x => x.StatusCode == HttpStatusCode.BadRequest).WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
new usages: var waitAndRetryPolicy = Policy.Handle < SoapException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => Logger.Error(exception, "?????? ??? ??????? ??????. ???: {code}. ?????????: {message}. ????? ???????? ?? ????????? ???????: {timeSpan}. ???????: {retryCount}", exception.HResult, exception.Message, timeSpan, retryCount));
new usages: var waitAndRetryPolicy = Policy.HandleResult < DeliveryStatus >(status => status != DeliveryStatus.Delivered).WaitAndRetryAsync(11, retryAttempt => TimeSpan.FromSeconds(10 * retryAttempt),(result, timeSpan, retryCount, context) => Logger.Info("????????? {messageId} ??? ?????? {appId} ??????? {userName} ?? ??????????. ??????? ?????? ???????? {status}. ????? ???????? ?? ????????? ???????: {timeSpan}. ???????: {retryCount}", messageId, applicationId, userName ?? "",((SmsDeliveryStatus) result.Result).GetDescription(), timeSpan, retryCount));
new usages: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(result, timeSpan, retryCount, context) => Logger.Error(result.Exception, "?????? ? ??????? ?????????? ????????. ???: {statusCode}. ????? ???????? ?? ????????? ???????: {timeSpan}. ???????: {retryCount} {request}", result.Result.StatusCode, timeSpan, retryCount, requestContent));
new usages: var waitAndRetryPolicy = Policy.HandleResult < ClientValidationRequest >(result => result ?.Result ==(int) ClientValidationResult.Requested).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < bool >(result => result == false).WaitAndRetryAsync(RetryCount, i => TimeSpan.FromSeconds(WaitSecondsBeforeRetry));
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retriesCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan) => { logger.LogError(exception, $"Operation failed, retrying in {timeSpan.Seconds} seconds"); });
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
new usages: var retryFailedUserPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
new usages: var policy = Policy.Handle < ResponseException >().Or < ConnectionPoolBusyException >().Or < ServerUnavailableException >().WaitAndRetryAsync(retryCount : 10, sleepDurationProvider :(attempt, exception, context) => { if(exception is ResponseException responseException && responseException.CosmosDbStatusCode() == RetryAfterStatusCode) { return TimeSpan.FromSeconds(5 + 5 * attempt * _jitterer.NextDouble()); } _logger.LogInformation($"Exception {exception.GetType()}. Retry immediately"); return TimeSpan.Zero; }, onRetryAsync :(exception, waitTime, attempt, _) => { totalWaitTime = totalWaitTime.Add(waitTime); retryCount = attempt; if(exception is ResponseException responseException) { var exceptionRu = CosmosResponse.ParseRequestCharge(responseException.StatusAttributes); totalRu += exceptionRu; _logger.LogInformation($"ResponseException cost {exceptionRu}RU"); } if(exception is ConnectionPoolBusyException || exception is ServerUnavailableException) { _logger.LogInformation($"Resetting the GremlinClient after experiencing an '{exception.GetType()}'"); _factory.ClearGraphClient(); } return Task.CompletedTask; });
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
new usages: var retryPolice = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
new usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxtrys, x => seconds);
new usages: var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.GatewayTimeout || msg.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
new usages: var policy = Policy.Handle < HttpRequestException >().Or < OperationCanceledException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(delayAfterFailure));
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(10));
new usages: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(policyConfigs.RetryCount, _ => TimeSpan.FromMilliseconds(policyConfigs.RetryDelayInMs));
new usages: var httpRetryPolicy = Policy.Handle < HttpRequestException >().Or < TaskCanceledException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(RetryRequired).WaitAndRetryAsync(GetBackOff(maxRetries));
new usages: var retryAfterPolicy = Policy.HandleResult < HttpResponseMessage >(ContainsRetryAfterHeader).WaitAndRetryAsync(maxRetries, sleepDurationProvider,(outcome, timespan, retryCount, context) => Task.CompletedTask);
new usages: var retryPolicy = HandleResult().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount, retryAttempt => retryDelay);
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); });
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
new usages: AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask; });
new usages: var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask; });
new usages: var retry = Policy.Handle < Exception >().WaitAndRetryAsync(Backoff.LinearBackoff(TimeSpan.FromSeconds(settings.RetryInitialDelaySeconds), settings.RetryCount),(exception, span, retryCount, context) => { logger.LogError(exception, "{@EventType} {@Realm} {@TimeSpan} {@retryCount}", "Retry", description, span, retryCount); });
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(exception, timeSpan, retryCount, context) => { });
new usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
new usages: IAsyncPolicy < HttpResponseMessage > policy = Policy.Handle < SocketException >().OrTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
new usages: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
new usages: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var retry = Policy < HttpResponseMessage >.Handle < Exception >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
new usages: var policy = Policy.Handle < InvalidOperationException >().Or < Exception >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); });
new usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
new usages: AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask.ConfigureAwait(false); });
new usages: var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask.ConfigureAwait(false); });
new usages: var policyRetry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(3, retryTimespan => TimeSpan.FromSeconds(Math.Pow(2, retryTimespan)),(exception, timespan, retryCount, context) => { var msg = $"? {retryCount} ??????? " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); });
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(e => HttpStatusCodeWorthRetry.ToList().Contains((int) e.StatusCode)).WaitAndRetryAsync(MaxRetryCount, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => PolicyLog($"API is throttling our requests automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"));
new usages: var policy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000));
new usages: AsyncRetryPolicy retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var polly = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, pause => TimeSpan.FromSeconds(5));
new usages: var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(_appSettings.RetryAttempt, retryAttempt => TimeSpan.FromMilliseconds(3000));
new usages: var retryPolicy = Policy.HandleResult < IRestResponse >(x => FindWarning(x) is null && x.StatusCode != HttpStatusCode.NotFound && x.StatusCode != HttpStatusCode.Unauthorized && x.StatusCode != HttpStatusCode.Conflict && x.StatusCode != HttpStatusCode.BadRequest && x.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(retryNumber, retryAttempt => TimeSpan.FromSeconds(retrySleepSeconds));
new usages: var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Trying for the {retryCount} time!"); Console.ForegroundColor = ConsoleColor.White; });
new usages: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
new usages: var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
new usages: var retryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(1),(result, span, retryCount, ctx) => { Console.WriteLine($"Retrying({retryCount})..."); });
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < Exception >().OrResult < HttpResponseMessage >(res => { return res.StatusCode != System.Net.HttpStatusCode.OK; }).WaitAndRetryAsync(sleepDurations : new[] { TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(200), TimeSpan.FromMilliseconds(300) }, onRetry :(exception, ts, context) => { Console.WriteLine($"polly.retry:exMsg={exception.Exception ?.Message}, {ts.Minutes * 60 + ts.Seconds}"); });
new usages: var retryWaitPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
new usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
new usages: var retryPolicy = Policy.Handle < Exception >((ex) => { logger.Log(LogSeverity.Error,(ex.InnerException != null) ? ex.InnerException.Message : ex.Message + "\r\n GetTrendingStocks retry FAILURE"); return !(ex is Polly.CircuitBreaker.BrokenCircuitException); }).WaitAndRetryAsync(_retryCount, x => TimeSpan.FromMilliseconds(_sleepTimeAfterFail));
new usages: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
new usages: var policy = Policy.Handle < SentNotificationException >().WaitAndRetryAsync(_maxRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(3, retryAttempt)));
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r =>(int) r.StatusCode == 429).WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var retryPolicy = Policy.Handle < System.Net.Sockets.SocketException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
old usages: var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
old usages: RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
old usages: var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
old usages: IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
old usages: AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}????,??????!\r\n{1}", strFileName, exception.Message)); });
old usages: var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"??[{downloadUrl}?,????,????????]", Category.Warn, Priority.High); });
old usages: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
old usages: var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
old usages: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
============= Cluster end ==============

generalized output is: var hole = hole.WaitAndRetryAsync hole;
Interesting new usage: AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose()):ArgumentList
Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound):InvocationExpression
Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Subsititution: var:IdentifierName -> AsyncRetryPolicy < HttpResponseMessage >:GenericName
Subsititution: Policy:IdentifierToken -> Policy < HttpResponseMessage >:GenericName
Correponding input: Policy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Input to synthesize the program:
Policy policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context);
---------------------
var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context);
Policy policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => capturedContext = context);
---------------------
var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => capturedContext = context);
Policy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
---------------------
AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
predict is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds() },(_, __, context) => contextValue = context["key"].ToString());
output  is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds() },(_, __, context) => contextValue = context["key"].ToString());
----------------------------------------------------
old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
predict is null
old usage is var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
predict is null
old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
predict is null
old usage is RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
predict is null
old usage is RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
predict is null
old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
predict is null
old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
predict is null
old usage is var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
predict is null
old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
predict is null
old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
predict is null
old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
predict is null
old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
predict is null
old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
predict is null
old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
predict is null
old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
predict is null
old usage is AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
predict is null
old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
predict is null
old usage is Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
predict is var exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usage is Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
predict is var exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
predict is null
old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
predict is null
old usage is var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
predict is null
old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
predict is null
old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}????,??????!\r\n{1}", strFileName, exception.Message)); });
predict is null
old usage is var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
predict is null
old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"??[{downloadUrl}?,????,????????]", Category.Warn, Priority.High); });
predict is null
old usage is Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
predict is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
old usage is var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
predict is null
old usage is Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
predict is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
total correct cases : 1 totalTestCases 1 Successful rate is 1
