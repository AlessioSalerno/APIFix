Configuration: 
---- UseAdditionalOutput: False
---- UseAdditionalInput : False
---- OnlyNewUsage       : False
---- GivenExample       : 1
---- UseTypedUsage      : False
---- NewKeyWords        : 
---- OldKeyWords        : 
---- OldUsageThreashold : 0.1
---- NewUsageThreashold : 0.25
load 3 relevant edits!
load 867 old relevant usages
Log: invoke synthesis engine...
Log: the size of unRolledEdits is: 3
Log: add old usage var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: add old usage var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
Log: add old usage var retry = Policy.Handle < DbException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnPolicyRetry);
Log: add old usage var retry = Policy.Handle < DbException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry);
Log: add old usage var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
Log: add old usage RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
Log: add old usage IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream = new MemoryStream());
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: add old usage var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
Log: add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
Log: add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
Log: add old usage var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.StatusCode ==(System.Net.HttpStatusCode) 429) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}")).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.5 * Math.Pow(2, attempt)));
Log: add old usage var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"NotStarted\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Failed\"}")).WaitAndRetryAsync(20, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
Log: add old usage var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: add old usage var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
Log: add old usage IAsyncPolicy AdoRetryPolicy = Policy.Handle < Exception >(ex => true).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 4));
Log: add old usage var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
Log: add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
Log: add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
Log: add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var authorisation = Policy.HandleResult < ValidatedToken >(_ => ! _.Succeeded).WaitAndRetryAsync(retries, SleepDurationProvider, async(outcome, retryNumber, context) => await actionToRetryOnFailure);
Log: add old usage var policyRetry = Policy.HandleResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(retryWaitsec),(resultPolly, timeSpan, countRetried, context) => { System.Console.WriteLine($"Request failed with {resultPolly.Result.StatusCode}"); });
Log: add old usage var retry = Policy.Handle < HttpRequestException >().Or < Polly.Timeout.TimeoutRejectedException >().OrResult < HttpResponseMessage >(response => { return retriable.Contains((int) response.StatusCode); }).WaitAndRetryAsync(retryCount : 5, sleepDurationProvider :(retryCount, response, context) => { var serverWait = response.Result ?.Headers.RetryAfter ?.Delta; var clientWait =(double) rand.Next(retryBaseDelay,(int) Math.Pow(2, retryCount) * retryMultiplier); var wait = clientWait; if(serverWait.HasValue) { wait = serverWait.Value.TotalMilliseconds + clientWait; } return TimeSpan.FromMilliseconds(wait); }, onRetryAsync :(response, sleepTime, retryCount, content) => Task.CompletedTask);
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var executionPolicy = Policy.Handle < ProvisionedThroughputExceededException >().WaitAndRetryAsync(10000,(retryCount) => TimeSpan.FromMilliseconds(250),(e, t, i, c) => OnRetry(request, e, t, i));
Log: add old usage var retryPolicy = Policy.Handle < RetryNeededException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(retryAttempt), onRetry :(ex, delay, context, tsk) => { Console.WriteLine($"Retrying exception {ex.ToAsyncString()}"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var _httpRequestPolicy = Policy < MovieDetail >.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(additionalRetries, retryAttempt => TimeSpan.FromSeconds(1));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(RetryCount, retryAttemp => RetryWaitTime,(exception, span, context) => { Trace.TraceError($"{DateTime.Now}: Error Sending Message, retry attempt: {span}, error: {exception}"); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
Log: add old usage var retryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(3, j => TimeSpan.FromSeconds(2),(result, timeSpan, retryCount, context) => { client = new HttpClient(); if(retryCount == 1) { client.BaseAddress = new Uri(creditcardServiceBaseAddress_2 + "1"); LoggingFunction("Retry logic: Start with Alternative 1", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 1 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } else { client.BaseAddress = new Uri(creditcardServiceBaseAddress_3); LoggingFunction("Retry logic: Start with Alternative 2", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 2 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } });
Log: add old usage AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Log: add old usage var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < StorageException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
Log: add old usage var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
Log: add old usage var trainRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var addFaceRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var findRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var addRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var matchRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var exceptionPolicy = Policy.Handle < HttpRequestException >().Or < WebException >().Or < InvalidOperationException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains((int) r.StatusCode)).OrResult(r => r.IsSuccessStatusCode == false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
Log: add old usage var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var connectPolicy = Policy.HandleResult < bool >(false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: add old usage var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { Console.WriteLine($"Received {exception.GetType()}{exception.Message}"); Console.WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: add old usage var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: add old usage var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(ex, timeSpan) => { Console.WriteLine($"Exception: {ex.Message}"); Console.WriteLine($"Retrying in {timeSpan.Seconds} seconds"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}下载异常，开始下载重试！\r\n{1}", strFileName, exception.Message)); });
Log: add old usage var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"下载[{downloadUrl}时，发生异常，正在进行重试下载]", Category.Warn, Priority.High); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage Polly.Retry.RetryPolicy < int > politicaWaitAndRetry = Polly.Policy.HandleResult < int >(i => true).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(7) },(e, t, i, c) => ReportPollyError(e, t, i, c));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: add old usage var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: add old usage var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: add old usage var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(exception, timeSpan, retryCount, context) => ManageRetryException(exception, timeSpan, retryCount, context));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var retryPolicy = Policy.Handle < Exception >(e => ! cancellationToken.IsCancellationRequested).WaitAndRetryAsync(policyMaxAttempts, attempt => TimeSpan.FromSeconds(retrySeconds),(exception, timeSpan, attempt, context) => { if(attempt == 1) { _log.WriteWarningAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl}. Retry in {retrySeconds} sec.", exception.Message).GetAwaiter().GetResult(); } if(attempt % policyMaxAttempts == 0) { _log.WriteErrorAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl} after {policyMaxAttempts} attempts", exception).GetAwaiter().GetResult(); } });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < ApiConnectionException >().WaitAndRetryAsync(DecorrelatedJitter(50, TimeSpan.FromMilliseconds(250), TimeSpan.FromSeconds(5)), onRetry :(exception, span, count, context) => { Console.WriteLine($"Action failed with error of \"{exception.Message}\". Waiting {span.TotalMilliseconds}ms to retry (#{count})"); });
Log: add old usage var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage IAsyncPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry :(exception, retryTimespan) => Log.Logger.Error(exception, $"Retry count {retryTimespan}"));
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(2, retryCount => TimeSpan.FromSeconds(2),(exception, timeSpan, retryCount, context) => { _logger.LogWarning($"Call to {url} failed - Retry {retryCount} : TimeSpan {timeSpan} : Ex {exception.Message}"); });
Log: add old usage var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage Polly.Retry.RetryPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3,(retry) => TimeSpan.FromSeconds(2),(ex, ts, attempt, context) => { logger.LogWarning($"An error occurred in attempt number {attempt} to release message {message.MessageId}" + $" in subscription \"{subscription}\": {ex.GetType().Name + " - " + ex.Message}"); });
Log: add old usage var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: add old usage var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: ============== Cluster start ==============
- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => contextData = context);
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => contextData = context);

- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => capturedContext = context);
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => capturedContext = context);

- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds()
                },
                (_, __, context) => contextValue = context["key"].ToString());
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds()
                },
                (_, __, context) => contextValue = context["key"].ToString());

old usages: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
old usages: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
old usages: var retry = Policy.Handle < DbException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnPolicyRetry);
old usages: var retry = Policy.Handle < DbException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry);
old usages: var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
old usages: RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
old usages: IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream = new MemoryStream());
old usages: var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
old usages: var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
old usages: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.StatusCode ==(System.Net.HttpStatusCode) 429) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}")).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.5 * Math.Pow(2, attempt)));
old usages: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"NotStarted\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Failed\"}")).WaitAndRetryAsync(20, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
old usages: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
old usages: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
old usages: IAsyncPolicy AdoRetryPolicy = Policy.Handle < Exception >(ex => true).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 4));
old usages: var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var authorisation = Policy.HandleResult < ValidatedToken >(_ => ! _.Succeeded).WaitAndRetryAsync(retries, SleepDurationProvider, async(outcome, retryNumber, context) => await actionToRetryOnFailure);
old usages: var policyRetry = Policy.HandleResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(retryWaitsec),(resultPolly, timeSpan, countRetried, context) => { System.Console.WriteLine($"Request failed with {resultPolly.Result.StatusCode}"); });
old usages: var retry = Policy.Handle < HttpRequestException >().Or < Polly.Timeout.TimeoutRejectedException >().OrResult < HttpResponseMessage >(response => { return retriable.Contains((int) response.StatusCode); }).WaitAndRetryAsync(retryCount : 5, sleepDurationProvider :(retryCount, response, context) => { var serverWait = response.Result ?.Headers.RetryAfter ?.Delta; var clientWait =(double) rand.Next(retryBaseDelay,(int) Math.Pow(2, retryCount) * retryMultiplier); var wait = clientWait; if(serverWait.HasValue) { wait = serverWait.Value.TotalMilliseconds + clientWait; } return TimeSpan.FromMilliseconds(wait); }, onRetryAsync :(response, sleepTime, retryCount, content) => Task.CompletedTask);
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var executionPolicy = Policy.Handle < ProvisionedThroughputExceededException >().WaitAndRetryAsync(10000,(retryCount) => TimeSpan.FromMilliseconds(250),(e, t, i, c) => OnRetry(request, e, t, i));
old usages: var retryPolicy = Policy.Handle < RetryNeededException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(retryAttempt), onRetry :(ex, delay, context, tsk) => { Console.WriteLine($"Retrying exception {ex.ToAsyncString()}"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var _httpRequestPolicy = Policy < MovieDetail >.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(additionalRetries, retryAttempt => TimeSpan.FromSeconds(1));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(RetryCount, retryAttemp => RetryWaitTime,(exception, span, context) => { Trace.TraceError($"{DateTime.Now}: Error Sending Message, retry attempt: {span}, error: {exception}"); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
old usages: var retryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(3, j => TimeSpan.FromSeconds(2),(result, timeSpan, retryCount, context) => { client = new HttpClient(); if(retryCount == 1) { client.BaseAddress = new Uri(creditcardServiceBaseAddress_2 + "1"); LoggingFunction("Retry logic: Start with Alternative 1", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 1 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } else { client.BaseAddress = new Uri(creditcardServiceBaseAddress_3); LoggingFunction("Retry logic: Start with Alternative 2", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 2 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } });
old usages: AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
old usages: var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < StorageException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
old usages: var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
old usages: var trainRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var addFaceRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var findRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var addRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var matchRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var exceptionPolicy = Policy.Handle < HttpRequestException >().Or < WebException >().Or < InvalidOperationException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains((int) r.StatusCode)).OrResult(r => r.IsSuccessStatusCode == false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
old usages: var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var connectPolicy = Policy.HandleResult < bool >(false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { Console.WriteLine($"Received {exception.GetType()}{exception.Message}"); Console.WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
old usages: var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
old usages: var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(ex, timeSpan) => { Console.WriteLine($"Exception: {ex.Message}"); Console.WriteLine($"Retrying in {timeSpan.Seconds} seconds"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}下载异常，开始下载重试！\r\n{1}", strFileName, exception.Message)); });
old usages: var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"下载[{downloadUrl}时，发生异常，正在进行重试下载]", Category.Warn, Priority.High); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: Polly.Retry.RetryPolicy < int > politicaWaitAndRetry = Polly.Policy.HandleResult < int >(i => true).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(7) },(e, t, i, c) => ReportPollyError(e, t, i, c));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
old usages: var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
old usages: var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
old usages: var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(exception, timeSpan, retryCount, context) => ManageRetryException(exception, timeSpan, retryCount, context));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var retryPolicy = Policy.Handle < Exception >(e => ! cancellationToken.IsCancellationRequested).WaitAndRetryAsync(policyMaxAttempts, attempt => TimeSpan.FromSeconds(retrySeconds),(exception, timeSpan, attempt, context) => { if(attempt == 1) { _log.WriteWarningAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl}. Retry in {retrySeconds} sec.", exception.Message).GetAwaiter().GetResult(); } if(attempt % policyMaxAttempts == 0) { _log.WriteErrorAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl} after {policyMaxAttempts} attempts", exception).GetAwaiter().GetResult(); } });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < ApiConnectionException >().WaitAndRetryAsync(DecorrelatedJitter(50, TimeSpan.FromMilliseconds(250), TimeSpan.FromSeconds(5)), onRetry :(exception, span, count, context) => { Console.WriteLine($"Action failed with error of \"{exception.Message}\". Waiting {span.TotalMilliseconds}ms to retry (#{count})"); });
old usages: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: IAsyncPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry :(exception, retryTimespan) => Log.Logger.Error(exception, $"Retry count {retryTimespan}"));
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(2, retryCount => TimeSpan.FromSeconds(2),(exception, timeSpan, retryCount, context) => { _logger.LogWarning($"Call to {url} failed - Retry {retryCount} : TimeSpan {timeSpan} : Ex {exception.Message}"); });
old usages: var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: Polly.Retry.RetryPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3,(retry) => TimeSpan.FromSeconds(2),(ex, ts, attempt, context) => { logger.LogWarning($"An error occurred in attempt number {attempt} to release message {message.MessageId}" + $" in subscription \"{subscription}\": {ex.GetType().Name + " - " + ex.Message}"); });
old usages: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
old usages: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
============= Cluster end ==============

Log: Input to synthesize the program:
Log: Policy policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context);
Log: ---------------------
Log: var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context);
Log: predict is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => capturedContext = context);
Log: output  is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => capturedContext = context);
Log: ----------------------------------------------------
Log: predict is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds() },(_, __, context) => contextValue = context["key"].ToString());
Log: output  is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds() },(_, __, context) => contextValue = context["key"].ToString());
Log: ----------------------------------------------------
Log: old usage is var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: predict is null
Log: old usage is var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: predict is null
Log: old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
Log: predict is null
Log: old usage is var retry = Policy.Handle < DbException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnPolicyRetry);
Log: predict is null
Log: old usage is var retry = Policy.Handle < DbException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry);
Log: predict is null
Log: old usage is var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
Log: predict is null
Log: old usage is RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream = new MemoryStream());
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.StatusCode ==(System.Net.HttpStatusCode) 429) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}")).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.5 * Math.Pow(2, attempt)));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"NotStarted\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Failed\"}")).WaitAndRetryAsync(20, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
Log: predict is null
Log: old usage is var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: predict is null
Log: old usage is var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
Log: predict is null
Log: old usage is IAsyncPolicy AdoRetryPolicy = Policy.Handle < Exception >(ex => true).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 4));
Log: predict is null
Log: old usage is var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
Log: predict is null
Log: old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var authorisation = Policy.HandleResult < ValidatedToken >(_ => ! _.Succeeded).WaitAndRetryAsync(retries, SleepDurationProvider, async(outcome, retryNumber, context) => await actionToRetryOnFailure);
Log: predict is null
Log: old usage is var policyRetry = Policy.HandleResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(retryWaitsec),(resultPolly, timeSpan, countRetried, context) => { System.Console.WriteLine($"Request failed with {resultPolly.Result.StatusCode}"); });
Log: predict is null
Log: old usage is var retry = Policy.Handle < HttpRequestException >().Or < Polly.Timeout.TimeoutRejectedException >().OrResult < HttpResponseMessage >(response => { return retriable.Contains((int) response.StatusCode); }).WaitAndRetryAsync(retryCount : 5, sleepDurationProvider :(retryCount, response, context) => { var serverWait = response.Result ?.Headers.RetryAfter ?.Delta; var clientWait =(double) rand.Next(retryBaseDelay,(int) Math.Pow(2, retryCount) * retryMultiplier); var wait = clientWait; if(serverWait.HasValue) { wait = serverWait.Value.TotalMilliseconds + clientWait; } return TimeSpan.FromMilliseconds(wait); }, onRetryAsync :(response, sleepTime, retryCount, content) => Task.CompletedTask);
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var executionPolicy = Policy.Handle < ProvisionedThroughputExceededException >().WaitAndRetryAsync(10000,(retryCount) => TimeSpan.FromMilliseconds(250),(e, t, i, c) => OnRetry(request, e, t, i));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < RetryNeededException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(retryAttempt), onRetry :(ex, delay, context, tsk) => { Console.WriteLine($"Retrying exception {ex.ToAsyncString()}"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var _httpRequestPolicy = Policy < MovieDetail >.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(additionalRetries, retryAttempt => TimeSpan.FromSeconds(1));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(RetryCount, retryAttemp => RetryWaitTime,(exception, span, context) => { Trace.TraceError($"{DateTime.Now}: Error Sending Message, retry attempt: {span}, error: {exception}"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
Log: predict is null
Log: old usage is var retryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(3, j => TimeSpan.FromSeconds(2),(result, timeSpan, retryCount, context) => { client = new HttpClient(); if(retryCount == 1) { client.BaseAddress = new Uri(creditcardServiceBaseAddress_2 + "1"); LoggingFunction("Retry logic: Start with Alternative 1", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 1 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } else { client.BaseAddress = new Uri(creditcardServiceBaseAddress_3); LoggingFunction("Retry logic: Start with Alternative 2", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 2 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } });
Log: predict is null
Log: old usage is AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Log: predict is null
Log: old usage is var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is var exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: old usage is Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is var exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < StorageException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
Log: predict is null
Log: old usage is var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
Log: predict is null
Log: old usage is var trainRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var addFaceRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var findRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var addRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var matchRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var exceptionPolicy = Policy.Handle < HttpRequestException >().Or < WebException >().Or < InvalidOperationException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains((int) r.StatusCode)).OrResult(r => r.IsSuccessStatusCode == false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
Log: predict is null
Log: old usage is var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var connectPolicy = Policy.HandleResult < bool >(false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { Console.WriteLine($"Received {exception.GetType()}{exception.Message}"); Console.WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: predict is null
Log: old usage is var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: predict is null
Log: old usage is var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(ex, timeSpan) => { Console.WriteLine($"Exception: {ex.Message}"); Console.WriteLine($"Retrying in {timeSpan.Seconds} seconds"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}下载异常，开始下载重试！\r\n{1}", strFileName, exception.Message)); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"下载[{downloadUrl}时，发生异常，正在进行重试下载]", Category.Warn, Priority.High); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is Polly.Retry.RetryPolicy < int > politicaWaitAndRetry = Polly.Policy.HandleResult < int >(i => true).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(7) },(e, t, i, c) => ReportPollyError(e, t, i, c));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: predict is null
Log: old usage is var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: predict is null
Log: old usage is var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: predict is null
Log: old usage is var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(exception, timeSpan, retryCount, context) => ManageRetryException(exception, timeSpan, retryCount, context));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >(e => ! cancellationToken.IsCancellationRequested).WaitAndRetryAsync(policyMaxAttempts, attempt => TimeSpan.FromSeconds(retrySeconds),(exception, timeSpan, attempt, context) => { if(attempt == 1) { _log.WriteWarningAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl}. Retry in {retrySeconds} sec.", exception.Message).GetAwaiter().GetResult(); } if(attempt % policyMaxAttempts == 0) { _log.WriteErrorAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl} after {policyMaxAttempts} attempts", exception).GetAwaiter().GetResult(); } });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < ApiConnectionException >().WaitAndRetryAsync(DecorrelatedJitter(50, TimeSpan.FromMilliseconds(250), TimeSpan.FromSeconds(5)), onRetry :(exception, span, count, context) => { Console.WriteLine($"Action failed with error of \"{exception.Message}\". Waiting {span.TotalMilliseconds}ms to retry (#{count})"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: predict is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is IAsyncPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry :(exception, retryTimespan) => Log.Logger.Error(exception, $"Retry count {retryTimespan}"));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(2, retryCount => TimeSpan.FromSeconds(2),(exception, timeSpan, retryCount, context) => { _logger.LogWarning($"Call to {url} failed - Retry {retryCount} : TimeSpan {timeSpan} : Ex {exception.Message}"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is Polly.Retry.RetryPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3,(retry) => TimeSpan.FromSeconds(2),(ex, ts, attempt, context) => { logger.LogWarning($"An error occurred in attempt number {attempt} to release message {message.MessageId}" + $" in subscription \"{subscription}\": {ex.GetType().Name + " - " + ex.Message}"); });
Log: predict is null
Log: old usage is var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: predict is null
Log: old usage is var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: predict is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
total correct cases : 2 totalTestCases 2 Successful rate is 1
The successful rate for transforming old usages: 4 / 195
