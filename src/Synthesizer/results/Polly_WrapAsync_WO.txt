Configuration: 
---- UseAdditionalOutput: True
---- UseAdditionalInput : False
---- OnlyNewUsage       : False
---- GivenExample       : 1
---- UseTypedUsage      : False
---- NewKeyWords        : 
---- OldKeyWords        : 
---- OldUsageThreashold : 0.1
---- NewUsageThreashold : 0.25
load 5 relevant edits!
load 237 old relevant usages
load 110 new relevant usages
Log: invoke synthesis engine...
Log: the size of unRolledEdits is: 7
size of new usage: 110
Log: add new usage Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
Log: add new usage Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
Log: add new usage Policy.WrapAsync(CreatePolicies().ToArray())
Log: add new usage Policy.WrapAsync(CreatePolicies().ToArray())
Log: add new usage var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: add new usage var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage policy.WrapAsync(Policy.BulkheadAsync(MaxParallelization, MaxQueuingActions))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(RetryTimes, t => RetryInterval))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(Timeout, TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowed, BreakTime))
Log: add new usage policy.WrapAsync(Policy.BulkheadAsync(MaxParallelization, MaxQueuingActions))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(RetryTimes, t => RetryInterval))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(Timeout, TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowed, BreakTime))
Log: add new usage Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
Log: add new usage Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
Log: add new usage var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: add new usage var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
Log: add new usage Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
Log: add new usage var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: add new usage var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage exceptionPolicy.WrapAsync(falseResultPolicy)
Log: add new usage exceptionPolicy.WrapAsync(falseResultPolicy)
Log: add new usage var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: add new usage var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
Log: add new usage Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
Log: add new usage Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
Log: add new usage Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
Log: add new usage fallback.WrapAsync(retry)
Log: add new usage fallback.WrapAsync(retry)
Log: add new usage Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
Log: add new usage Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
Log: add new usage Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
Log: add new usage Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option));
Log: add new usage Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option))
Log: add new usage return Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option));
Log: add new usage Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option))
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
Log: add new usage Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy)
Log: add new usage Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
Log: add new usage Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy)
Log: add new usage Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: add new usage var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: add new usage var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage retry.WrapAsync(timeoutPolicy)
Log: add new usage retry.WrapAsync(timeoutPolicy)
Log: add new usage var policy = retry.WrapAsync(timeoutPolicy);
Log: add new usage var policy = retry.WrapAsync(timeoutPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(_timeoutPolicy, _retryPolicy)
Log: add new usage Policy.WrapAsync(_timeoutPolicy, _retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy)
Log: add new usage Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy)
Log: add new usage var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: add new usage var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(otherHttpRetryPolicy, azureFunctionHttpsRetryPolicy)
Log: add new usage Policy.WrapAsync(otherHttpRetryPolicy, azureFunctionHttpsRetryPolicy)
Log: add new usage _collapserPolicy.WrapAsync(cachePolicy)
Log: add new usage _collapserPolicy.WrapAsync(cachePolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage timeout.WrapAsync(retry)
Log: add new usage timeout.WrapAsync(retry)
Log: add new usage var policies = timeout.WrapAsync(retry);
Log: add new usage var policies = timeout.WrapAsync(retry);
Log: add new usage Policy.WrapAsync(retryPolicy, circuitBreakerPolicy)
Log: add new usage Policy.WrapAsync(retryPolicy, circuitBreakerPolicy)
Log: add new usage var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: add new usage var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: add new usage Policy.WrapAsync(cachePolicy, retryPolicy)
Log: add new usage Policy.WrapAsync(cachePolicy, retryPolicy)
Log: add new usage var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: add new usage var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: add new usage Policy.WrapAsync(cachePolicy, retryPolicy)
Log: add new usage Policy.WrapAsync(cachePolicy, retryPolicy)
Log: add new usage var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: add new usage var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker)
Log: add new usage Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker)
Log: add new usage var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
Log: add new usage var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
Log: add new usage retryAfterPolicy.WrapAsync(httpRetryPolicy).WrapAsync(timeoutPolicy)
Log: add new usage retryAfterPolicy.WrapAsync(httpRetryPolicy)
Log: add new usage retryAfterPolicy.WrapAsync(httpRetryPolicy).WrapAsync(timeoutPolicy)
Log: add new usage retryAfterPolicy.WrapAsync(httpRetryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(() => asyncHttpCall.Invoke(requestMessage, cancellationToken));
Log: add new usage timeOutPolicy.WrapAsync(retryAndSleepPolicy)
Log: add new usage return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(() => asyncHttpCall.Invoke(requestMessage, cancellationToken));
Log: add new usage timeOutPolicy.WrapAsync(retryAndSleepPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker)
Log: add new usage Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker)
Log: add new usage var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
Log: add new usage var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
Log: add new usage return Policy.WrapAsync(retry, breaker);
Log: add new usage Policy.WrapAsync(retry, breaker)
Log: add new usage return Policy.WrapAsync(retry, breaker);
Log: add new usage Policy.WrapAsync(retry, breaker)
Log: add new usage policyFallBack.WrapAsync(policy)
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOut), Polly.Timeout.TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(DurationOfBreak)))
Log: add new usage policyFallBack.WrapAsync(policy)
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOut), Polly.Timeout.TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(DurationOfBreak)))
Log: add new usage Policy.WrapAsync(policy, timeOut)
Log: add new usage Policy.WrapAsync(policy, retry)
Log: add new usage Policy.WrapAsync(fallback, circuitBreaker)
Log: add new usage Policy.WrapAsync(policy, timeOut)
Log: add new usage Policy.WrapAsync(policy, retry)
Log: add new usage Policy.WrapAsync(fallback, circuitBreaker)
Log: add new usage exceptionPolicy.WrapAsync(falseResultPolicy)
Log: add new usage exceptionPolicy.WrapAsync(falseResultPolicy)
Log: add new usage var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: add new usage var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(_policyCreator(normalizeOrigin).ToArray())
Log: add new usage Policy.WrapAsync(_policyCreator(normalizeOrigin).ToArray())
Log: add new usage Policy.WrapAsync(fallback2, bulk)
Log: add new usage Policy.WrapAsync(fallback, retry, breakPolicy)
Log: add new usage Policy.WrapAsync(fallback2, bulk)
Log: add new usage Policy.WrapAsync(fallback, retry, breakPolicy)
Log: add new usage var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
Log: add new usage var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
Log: add new usage var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
Log: add new usage var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy).AsAsyncPolicy < HttpResponseMessage >()
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
Log: add new usage Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy)
Log: add new usage Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy).AsAsyncPolicy < HttpResponseMessage >()
Log: add new usage Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
Log: add new usage Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy)
Log: add new usage Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
Log: add new usage var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
Log: add new usage var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: add new usage HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
Log: add new usage HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
Log: add new usage var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: add new usage var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: add new usage Policy.WrapAsync(_asyncPolicies.ToArray())
Log: add new usage Policy.WrapAsync(_asyncPolicies.ToArray())
Log: add new usage HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
Log: add new usage HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
Log: add new usage var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: add new usage var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(async() => { var newRequestMessage = await CloneHttpRequestMessage(requestMessage).ConfigureAwait(false); return await asyncHttpCall.Invoke(newRequestMessage, cancellationToken).ConfigureAwait(false); });
Log: add new usage timeOutPolicy.WrapAsync(retryAndSleepPolicy)
Log: add new usage return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(async() => { var newRequestMessage = await CloneHttpRequestMessage(requestMessage).ConfigureAwait(false); return await asyncHttpCall.Invoke(newRequestMessage, cancellationToken).ConfigureAwait(false); });
Log: add new usage timeOutPolicy.WrapAsync(retryAndSleepPolicy)
Log: add new usage Policy.WrapAsync(fallbackPolicy, _circuitBreakerPolicy)
Log: add new usage Policy.WrapAsync(fallbackPolicy, _circuitBreakerPolicy)
Log: add new usage Policy.WrapAsync(policyRetry, policyBreak)
Log: add new usage Policy.WrapAsync(policyRetry, policyBreak)
Log: add new usage var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
Log: add new usage var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
Log: add new usage Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
Log: add new usage Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
Log: add new usage return sharedBulkhead.WrapAsync(Component.GetPolicy());
Log: add new usage sharedBulkhead.WrapAsync(Component.GetPolicy())
Log: add new usage return sharedBulkhead.WrapAsync(Component.GetPolicy());
Log: add new usage sharedBulkhead.WrapAsync(Component.GetPolicy())
Log: add new usage return circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy());
Log: add new usage circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy())
Log: add new usage return circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy());
Log: add new usage circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy())
Log: add new usage return waitAndRetryPolicy.WrapAsync(Component.GetPolicy());
Log: add new usage waitAndRetryPolicy.WrapAsync(Component.GetPolicy())
Log: add new usage return waitAndRetryPolicy.WrapAsync(Component.GetPolicy());
Log: add new usage waitAndRetryPolicy.WrapAsync(Component.GetPolicy())
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(retryPolicy, timeoutPolicy);
Log: add new usage Policy.WrapAsync(retryPolicy, timeoutPolicy)
Log: add new usage return Policy.WrapAsync(retryPolicy, timeoutPolicy);
Log: add new usage Policy.WrapAsync(retryPolicy, timeoutPolicy)
Log: add new usage policyFallBack.WrapAsync(policy)
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOutMilliseconds), TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(IsForceDowngrade ? 1 : ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)))
Log: add new usage policyFallBack.WrapAsync(policy)
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
Log: add new usage policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOutMilliseconds), TimeoutStrategy.Pessimistic))
Log: add new usage policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(IsForceDowngrade ? 1 : ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)))
Log: add new usage Policy.WrapAsync(fallbackPolicy, retryPolicy)
Log: add new usage Policy.WrapAsync(fallbackPolicy, retryPolicy)
Log: add new usage var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
Log: add new usage var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.WrapAsync(fallback, breaker)
Log: add new usage Policy.WrapAsync(fallback, breaker)
Log: add new usage var policy = Policy.WrapAsync(fallback, breaker);
Log: add new usage var policy = Policy.WrapAsync(fallback, breaker);
Log: add new usage Policy.WrapAsync(retryPolicy, chaosPolicy)
Log: add new usage Policy.WrapAsync(retryPolicy, chaosPolicy)
Log: add new usage var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
Log: add new usage var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
Log: add new usage _unauthorizedPolicy.WrapAsync(_timeoutPolicy)
Log: add new usage _unauthorizedPolicy.WrapAsync(_timeoutPolicy)
Log: add new usage _fallbackPolicy.WrapAsync(_retryPolicy)
Log: add new usage _fallbackPolicy.WrapAsync(_retryPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy))
Log: add new usage Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)
Log: add new usage fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy))
Log: add new usage Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
Log: add new usage Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
Log: add new usage Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
Log: add new usage Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage RetryHelper.WrapAsync(downloadImageService.GetImage())
Log: add new usage RetryHelper.WrapAsync(downloadImageService.GetImage())
Log: add new usage RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachCelebrity.Name, this.settingsService.EntitySearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachCelebrity.Name, this.settingsService.EntitySearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.imageSearchService.GetSimilarImagesAsync(image, Settings.Settings.ImageSearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.imageSearchService.GetSimilarImagesAsync(image, Settings.Settings.ImageSearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachLandmark.Name, this.settingsService.EntitySearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachLandmark.Name, this.settingsService.EntitySearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.ocrService.RecognizeHandWritingTextRequest(image, this.settingsService.TextRecognitionAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.ocrService.RecognizeHandWritingTextRequest(image, this.settingsService.TextRecognitionAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.translatorService.Translate(this.Text, from, to, this.settingsService.TranslatorAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.translatorService.Translate(this.Text, from, to, this.settingsService.TranslatorAPIKey))
Log: add new usage return RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey));
Log: add new usage RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey))
Log: add new usage return RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey));
Log: add new usage RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.luisService.Proccess(this.settingsService.LuisAPPID, q : this.text, timezoneOffset : "0", verbose : "false", spellCheck : "false", staging : "false", apiKey : this.settingsService.LuisAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.luisService.Proccess(this.settingsService.LuisAPPID, q : this.text, timezoneOffset : "0", verbose : "false", spellCheck : "false", staging : "false", apiKey : this.settingsService.LuisAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.productsService.GetSimilar(imageStream, Settings.Settings.ImageSearchAPIKey))
Log: add new usage RetryHelper.WrapAsync(this.productsService.GetSimilar(imageStream, Settings.Settings.ImageSearchAPIKey))
Log: add new usage Forms.Common.RetryHelper.WrapAsync(this.service.RecognizePrintedText(image, APIKeys.ImageAnalysisAndTextRecognitionAPIKey))
Log: add new usage Forms.Common.RetryHelper.WrapAsync(this.service.RecognizePrintedText(image, APIKeys.ImageAnalysisAndTextRecognitionAPIKey))
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
Log: add new usage Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
Log: add new usage SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy()).WrapAsync(SimplePolicies.GetTimeoutPolicy())
Log: add new usage SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy())
Log: add new usage SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy()).WrapAsync(SimplePolicies.GetTimeoutPolicy())
Log: add new usage SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy())
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallbackPolicy.WrapAsync(retryPolicy)
Log: add new usage fallBackpolicy.WrapAsync(policy)
Log: add new usage fallBackpolicy.WrapAsync(policy)
Log: add new usage var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: add new usage var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: add new usage fallBackpolicy.WrapAsync(policy)
Log: add new usage fallBackpolicy.WrapAsync(policy)
Log: add new usage var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: add new usage var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: add old usage var policy = Policy.WrapAsync(retry, breaker);
Log: add old usage var policy = Policy.WrapAsync(retry, breaker);
Log: add old usage var policy = Policy.WrapAsync(retry, breaker);
Log: add old usage var policy = Policy.WrapAsync(retry, breaker);
Log: add old usage var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
Log: add old usage var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
Log: add old usage var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
Log: add old usage var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
Log: add old usage PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: add old usage PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: add old usage var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: add old usage var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: add old usage PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: add old usage PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: add old usage PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: add old usage var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
Log: add old usage var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
Log: add old usage var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
Log: add old usage var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
Log: add old usage var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
Log: add old usage var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
Log: add old usage var retryAndBreak = Policy.WrapAsync(retry, breaker);
Log: add old usage var retryAndBreak = Policy.WrapAsync(retry, breaker);
Log: add old usage IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
Log: add old usage IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
Log: ============== Cluster start ==============
- return ((Policy)outerPolicy).WrapAsync(innerPolicy);
----------------
+ return ((AsyncPolicy)outerPolicy).WrapAsync(innerPolicy);

new usages: return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
new usages: return Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option));
new usages: return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(() => asyncHttpCall.Invoke(requestMessage, cancellationToken));
new usages: return Policy.WrapAsync(retry, breaker);
new usages: return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(async() => { var newRequestMessage = await CloneHttpRequestMessage(requestMessage).ConfigureAwait(false); return await asyncHttpCall.Invoke(newRequestMessage, cancellationToken).ConfigureAwait(false); });
new usages: return sharedBulkhead.WrapAsync(Component.GetPolicy());
new usages: return circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy());
new usages: return waitAndRetryPolicy.WrapAsync(Component.GetPolicy());
new usages: return Policy.WrapAsync(retryPolicy, timeoutPolicy);
new usages: return RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey));
============= Cluster end ==============

Log: ============== Cluster start ==============
((Policy) outerPolicy).WrapAsync(innerPolicy)
----------------
((AsyncPolicy) outerPolicy).WrapAsync(innerPolicy)

new usages: Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
new usages: Policy.WrapAsync(CreatePolicies().ToArray())
new usages: Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
new usages: policy.WrapAsync(Policy.BulkheadAsync(MaxParallelization, MaxQueuingActions))
new usages: policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(RetryTimes, t => RetryInterval))
new usages: policy.WrapAsync(Policy.TimeoutAsync(Timeout, TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowed, BreakTime))
new usages: Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
new usages: exceptionPolicy.WrapAsync(falseResultPolicy)
new usages: Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
new usages: Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
new usages: fallback.WrapAsync(retry)
new usages: Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option))
new usages: Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
new usages: Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy)
new usages: Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
new usages: fallbackPolicy.WrapAsync(retryPolicy)
new usages: retry.WrapAsync(timeoutPolicy)
new usages: Policy.WrapAsync(_timeoutPolicy, _retryPolicy)
new usages: Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy)
new usages: Policy.WrapAsync(otherHttpRetryPolicy, azureFunctionHttpsRetryPolicy)
new usages: _collapserPolicy.WrapAsync(cachePolicy)
new usages: timeout.WrapAsync(retry)
new usages: Policy.WrapAsync(retryPolicy, circuitBreakerPolicy)
new usages: Policy.WrapAsync(cachePolicy, retryPolicy)
new usages: Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker)
new usages: retryAfterPolicy.WrapAsync(httpRetryPolicy).WrapAsync(timeoutPolicy)
new usages: retryAfterPolicy.WrapAsync(httpRetryPolicy)
new usages: timeOutPolicy.WrapAsync(retryAndSleepPolicy)
new usages: Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker)
new usages: Policy.WrapAsync(retry, breaker)
new usages: policyFallBack.WrapAsync(policy)
new usages: policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
new usages: policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOut), Polly.Timeout.TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(DurationOfBreak)))
new usages: Policy.WrapAsync(policy, timeOut)
new usages: Policy.WrapAsync(policy, retry)
new usages: Policy.WrapAsync(fallback, circuitBreaker)
new usages: Policy.WrapAsync(_policyCreator(normalizeOrigin).ToArray())
new usages: Policy.WrapAsync(fallback2, bulk)
new usages: Policy.WrapAsync(fallback, retry, breakPolicy)
new usages: Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy).AsAsyncPolicy < HttpResponseMessage >()
new usages: Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy)
new usages: HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
new usages: Policy.WrapAsync(_asyncPolicies.ToArray())
new usages: Policy.WrapAsync(fallbackPolicy, _circuitBreakerPolicy)
new usages: Policy.WrapAsync(policyRetry, policyBreak)
new usages: sharedBulkhead.WrapAsync(Component.GetPolicy())
new usages: circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy())
new usages: waitAndRetryPolicy.WrapAsync(Component.GetPolicy())
new usages: Policy.WrapAsync(retryPolicy, timeoutPolicy)
new usages: policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOutMilliseconds), TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(IsForceDowngrade ? 1 : ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)))
new usages: Policy.WrapAsync(fallbackPolicy, retryPolicy)
new usages: Policy.WrapAsync(fallback, breaker)
new usages: Policy.WrapAsync(retryPolicy, chaosPolicy)
new usages: _unauthorizedPolicy.WrapAsync(_timeoutPolicy)
new usages: _fallbackPolicy.WrapAsync(_retryPolicy)
new usages: fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy))
new usages: Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)
new usages: Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
new usages: RetryHelper.WrapAsync(downloadImageService.GetImage())
new usages: RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachCelebrity.Name, this.settingsService.EntitySearchAPIKey))
new usages: RetryHelper.WrapAsync(this.imageSearchService.GetSimilarImagesAsync(image, Settings.Settings.ImageSearchAPIKey))
new usages: RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachLandmark.Name, this.settingsService.EntitySearchAPIKey))
new usages: RetryHelper.WrapAsync(this.ocrService.RecognizeHandWritingTextRequest(image, this.settingsService.TextRecognitionAPIKey))
new usages: RetryHelper.WrapAsync(this.translatorService.Translate(this.Text, from, to, this.settingsService.TranslatorAPIKey))
new usages: RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey))
new usages: RetryHelper.WrapAsync(this.luisService.Proccess(this.settingsService.LuisAPPID, q : this.text, timezoneOffset : "0", verbose : "false", spellCheck : "false", staging : "false", apiKey : this.settingsService.LuisAPIKey))
new usages: RetryHelper.WrapAsync(this.productsService.GetSimilar(imageStream, Settings.Settings.ImageSearchAPIKey))
new usages: Forms.Common.RetryHelper.WrapAsync(this.service.RecognizePrintedText(image, APIKeys.ImageAnalysisAndTextRecognitionAPIKey))
new usages: SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy()).WrapAsync(SimplePolicies.GetTimeoutPolicy())
new usages: SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy())
new usages: fallBackpolicy.WrapAsync(policy)
============= Cluster end ==============

Log: ============== Cluster start ==============
- return ((Policy<TResult>)outerPolicy).WrapAsync(innerPolicy);
----------------
+ return ((AsyncPolicy<TResult>)outerPolicy).WrapAsync(innerPolicy);

new usages: return Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable);
new usages: return Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option));
new usages: return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(() => asyncHttpCall.Invoke(requestMessage, cancellationToken));
new usages: return Policy.WrapAsync(retry, breaker);
new usages: return timeOutPolicy.WrapAsync(retryAndSleepPolicy).ExecuteAsync(async() => { var newRequestMessage = await CloneHttpRequestMessage(requestMessage).ConfigureAwait(false); return await asyncHttpCall.Invoke(newRequestMessage, cancellationToken).ConfigureAwait(false); });
new usages: return sharedBulkhead.WrapAsync(Component.GetPolicy());
new usages: return circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy());
new usages: return waitAndRetryPolicy.WrapAsync(Component.GetPolicy());
new usages: return Policy.WrapAsync(retryPolicy, timeoutPolicy);
new usages: return RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey));
============= Cluster end ==============

Log: ============== Cluster start ==============
((Policy < TResult >) outerPolicy).WrapAsync(innerPolicy)
----------------
((AsyncPolicy < TResult >) outerPolicy).WrapAsync(innerPolicy)

new usages: Policy.WrapAsync(_policyCreator(normalizedOrigin).ToArray())
new usages: Policy.WrapAsync(CreatePolicies().ToArray())
new usages: Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicyForRecoverable)
new usages: policy.WrapAsync(Policy.BulkheadAsync(MaxParallelization, MaxQueuingActions))
new usages: policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(RetryTimes, t => RetryInterval))
new usages: policy.WrapAsync(Policy.TimeoutAsync(Timeout, TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowed, BreakTime))
new usages: Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy)
new usages: exceptionPolicy.WrapAsync(falseResultPolicy)
new usages: Policies < Spellings >.Complete.WrapAsync(Policy < Spellings >.Handle < TimeoutException >().FallbackAsync(new Spellings { spellings = new string[0] }))
new usages: Policies < ResultPreview >.Complete.WrapAsync(Policy < ResultPreview >.Handle < TimeoutException >().FallbackAsync(new ResultPreview { Results = new(string path, string body)[0] }))
new usages: fallback.WrapAsync(retry)
new usages: Policy.WrapAsync(GetRetryPolicyAsync(option), GetCircuitBreakerPolicyAsync(option))
new usages: Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy)
new usages: Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy)
new usages: Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy)
new usages: fallbackPolicy.WrapAsync(retryPolicy)
new usages: retry.WrapAsync(timeoutPolicy)
new usages: Policy.WrapAsync(_timeoutPolicy, _retryPolicy)
new usages: Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy)
new usages: Policy.WrapAsync(otherHttpRetryPolicy, azureFunctionHttpsRetryPolicy)
new usages: _collapserPolicy.WrapAsync(cachePolicy)
new usages: timeout.WrapAsync(retry)
new usages: Policy.WrapAsync(retryPolicy, circuitBreakerPolicy)
new usages: Policy.WrapAsync(cachePolicy, retryPolicy)
new usages: Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker)
new usages: retryAfterPolicy.WrapAsync(httpRetryPolicy).WrapAsync(timeoutPolicy)
new usages: retryAfterPolicy.WrapAsync(httpRetryPolicy)
new usages: timeOutPolicy.WrapAsync(retryAndSleepPolicy)
new usages: Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker)
new usages: Policy.WrapAsync(retry, breaker)
new usages: policyFallBack.WrapAsync(policy)
new usages: policy.WrapAsync(Policy.Handle < Exception >().WaitAndRetryAsync(MaxRetryTimes, i => TimeSpan.FromMilliseconds(RetryIntervalMilliseconds)))
new usages: policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOut), Polly.Timeout.TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(DurationOfBreak)))
new usages: Policy.WrapAsync(policy, timeOut)
new usages: Policy.WrapAsync(policy, retry)
new usages: Policy.WrapAsync(fallback, circuitBreaker)
new usages: Policy.WrapAsync(_policyCreator(normalizeOrigin).ToArray())
new usages: Policy.WrapAsync(fallback2, bulk)
new usages: Policy.WrapAsync(fallback, retry, breakPolicy)
new usages: Policy.TimeoutAsync(config.TotalResponseTimeoutInSeconds, TimeoutStrategy.Pessimistic).WrapAsync(waitAndRetryPolicy).AsAsyncPolicy < HttpResponseMessage >()
new usages: Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy)
new usages: HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)))
new usages: Policy.WrapAsync(_asyncPolicies.ToArray())
new usages: Policy.WrapAsync(fallbackPolicy, _circuitBreakerPolicy)
new usages: Policy.WrapAsync(policyRetry, policyBreak)
new usages: sharedBulkhead.WrapAsync(Component.GetPolicy())
new usages: circuitBreakerPolicyForRecoverable.WrapAsync(Component.GetPolicy())
new usages: waitAndRetryPolicy.WrapAsync(Component.GetPolicy())
new usages: Policy.WrapAsync(retryPolicy, timeoutPolicy)
new usages: policy.WrapAsync(Policy.TimeoutAsync(() => TimeSpan.FromMilliseconds(TimeOutMilliseconds), TimeoutStrategy.Pessimistic))
new usages: policy.WrapAsync(Policy.Handle < Exception >().CircuitBreakerAsync(IsForceDowngrade ? 1 : ExceptionsAllowedBeforeBreaking, TimeSpan.FromMilliseconds(MillisecondsOfBreak)))
new usages: Policy.WrapAsync(fallbackPolicy, retryPolicy)
new usages: Policy.WrapAsync(fallback, breaker)
new usages: Policy.WrapAsync(retryPolicy, chaosPolicy)
new usages: _unauthorizedPolicy.WrapAsync(_timeoutPolicy)
new usages: _fallbackPolicy.WrapAsync(_retryPolicy)
new usages: fallbackPolicy.WrapAsync(Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy))
new usages: Policy.WrapAsync(circuitBreakerPolicy, retryPolicy, timeoutPolicy)
new usages: Policy.Handle < DbException >().WaitAndRetryAsync(retryCount : RetryCount, sleepDurationProvider : retry => TimeSpan.FromMilliseconds(TimeSpan.FromMilliseconds(RetryDelay).TotalMilliseconds * retry), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"{exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {RetryCount}"); }).WrapAsync(_circuitBreakerPolicyAsync)
new usages: RetryHelper.WrapAsync(downloadImageService.GetImage())
new usages: RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachCelebrity.Name, this.settingsService.EntitySearchAPIKey))
new usages: RetryHelper.WrapAsync(this.imageSearchService.GetSimilarImagesAsync(image, Settings.Settings.ImageSearchAPIKey))
new usages: RetryHelper.WrapAsync(this.entitySearchService.GetEntities(eachLandmark.Name, this.settingsService.EntitySearchAPIKey))
new usages: RetryHelper.WrapAsync(this.ocrService.RecognizeHandWritingTextRequest(image, this.settingsService.TextRecognitionAPIKey))
new usages: RetryHelper.WrapAsync(this.translatorService.Translate(this.Text, from, to, this.settingsService.TranslatorAPIKey))
new usages: RetryHelper.WrapAsync(this.ocrService.RecognizePrintedText(image, this.settingsService.TextRecognitionAPIKey))
new usages: RetryHelper.WrapAsync(this.luisService.Proccess(this.settingsService.LuisAPPID, q : this.text, timezoneOffset : "0", verbose : "false", spellCheck : "false", staging : "false", apiKey : this.settingsService.LuisAPIKey))
new usages: RetryHelper.WrapAsync(this.productsService.GetSimilar(imageStream, Settings.Settings.ImageSearchAPIKey))
new usages: Forms.Common.RetryHelper.WrapAsync(this.service.RecognizePrintedText(image, APIKeys.ImageAnalysisAndTextRecognitionAPIKey))
new usages: SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy()).WrapAsync(SimplePolicies.GetTimeoutPolicy())
new usages: SimplePolicies.GetRetryPolicy().WrapAsync(SimplePolicies.GetCircuitBreakerPolicy())
new usages: fallBackpolicy.WrapAsync(policy)
============= Cluster end ==============

Log: ============== Cluster start ==============
PolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
----------------
AsyncPolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);

new usages: var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
new usages: var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
new usages: var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
new usages: var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
new usages: var policy = retry.WrapAsync(timeoutPolicy);
new usages: var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
new usages: var policies = timeout.WrapAsync(retry);
new usages: var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
new usages: var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
new usages: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
new usages: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
new usages: var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
new usages: var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
new usages: var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
new usages: var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
new usages: var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
new usages: var policy = Policy.WrapAsync(fallback, breaker);
new usages: var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
new usages: var retryWithFallback = fallBackpolicy.WrapAsync(policy);
old usages: var policy = Policy.WrapAsync(retry, breaker);
old usages: var policy = Policy.WrapAsync(retry, breaker);
old usages: var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
old usages: var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
old usages: PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
old usages: var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
old usages: PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
old usages: var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
old usages: var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
old usages: var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
old usages: var retryAndBreak = Policy.WrapAsync(retry, breaker);
old usages: IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
============= Cluster end ==============

Log: generalized output is: AsyncPolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Interesting new usage: var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (CreatePolicies().ToArray()):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policyWrap:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Interesting new usage: var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (waitAndRetryPolicyForError596, waitAndRetryPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> setup:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Interesting new usage: var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (falseResultPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> exceptionPolicy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (circuitBreakerPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Interesting new usage: var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (timeoutTryPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> circuitBreakerPolicy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Interesting new usage: var policy = retry.WrapAsync(timeoutPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (timeoutPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> retry:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policy = retry.WrapAsync(timeoutPolicy);
Interesting new usage: var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallbackPolicyStream, timeoutPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> warpStream:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Interesting new usage: var policies = timeout.WrapAsync(retry);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (retry):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> timeout:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policies:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policies = timeout.WrapAsync(retry);
Interesting new usage: var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (retryPolicy, circuitBreakerPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> wrap:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Interesting new usage: var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (cachePolicy, retryPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> meteoPolicy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Interesting new usage: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (circuitBreaker):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().FallbackAsync(cacheFunction):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
Interesting new usage: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (_circuitBreaker):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().FallbackAsync(cacheFunction):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
Interesting new usage: var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallback2, bulk):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> fallbackbulk:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap fallbackbulk = Policy.WrapAsync(fallback2, bulk);
Interesting new usage: var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallback, retry, breakPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> fallbackBreak:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (circuitBreakerPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
Interesting new usage: var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5))):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> policies:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Interesting new usage: var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (policyRetry, policyBreak):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policyWary:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policyWary = Policy.WrapAsync(policyRetry, policyBreak);
Interesting new usage: var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallbackPolicy, retryPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> wrapOfRetryAndFallback:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
Interesting new usage: var policy = Policy.WrapAsync(fallback, breaker);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallback, breaker):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policy = Policy.WrapAsync(fallback, breaker);
Interesting new usage: var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (retryPolicy, chaosPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policyWrap:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
Interesting new usage: var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (policy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> fallBackpolicy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> retryWithFallback:IdentifierToken
Log: Subsititution: AsyncPolicyWrap:IdentifierToken -> var:IdentifierToken
Correponding input: PolicyWrap retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: Input to synthesize the program:
Log: PolicyWrap policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: ---------------------
Log: var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: PolicyWrap setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: ---------------------
Log: var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: PolicyWrap policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: ---------------------
Log: var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: PolicyWrap waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: ---------------------
Log: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: PolicyWrap circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: ---------------------
Log: var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: PolicyWrap policy = retry.WrapAsync(timeoutPolicy);
Log: ---------------------
Log: var policy = retry.WrapAsync(timeoutPolicy);
Log: PolicyWrap warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: ---------------------
Log: var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: PolicyWrap policies = timeout.WrapAsync(retry);
Log: ---------------------
Log: var policies = timeout.WrapAsync(retry);
Log: PolicyWrap wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: ---------------------
Log: var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: PolicyWrap meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: ---------------------
Log: var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: old usage is var policy = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
Log: predict is null
Log: old usage is var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
Log: predict is null
Log: old usage is PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: predict is null
Log: old usage is var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: old usage is PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: predict is null
Log: old usage is PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: old usage is PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: predict is null
Log: old usage is var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
Log: predict is null
Log: old usage is var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
Log: predict is null
Log: old usage is var retryAndBreak = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
Log: predict is null
Log: ============== Cluster start ==============
PolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
----------------
AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);

PolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
----------------
AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);

new usages: var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
new usages: var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
new usages: var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
new usages: var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
new usages: var policy = retry.WrapAsync(timeoutPolicy);
new usages: var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
new usages: var policies = timeout.WrapAsync(retry);
new usages: var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
new usages: var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
new usages: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
new usages: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
new usages: var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
new usages: var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
new usages: var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
new usages: var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
new usages: var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
new usages: var policy = Policy.WrapAsync(fallback, breaker);
new usages: var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
new usages: var retryWithFallback = fallBackpolicy.WrapAsync(policy);
old usages: var policy = Policy.WrapAsync(retry, breaker);
old usages: var policy = Policy.WrapAsync(retry, breaker);
old usages: var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
old usages: var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
old usages: PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
old usages: var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
old usages: PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
old usages: var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
old usages: var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
old usages: var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
old usages: var retryAndBreak = Policy.WrapAsync(retry, breaker);
old usages: IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
============= Cluster end ==============

Log: generalized output is: AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Interesting new usage: var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (CreatePolicies().ToArray()):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policyWrap:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Interesting new usage: var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (waitAndRetryPolicyForError596, waitAndRetryPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> setup:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Interesting new usage: var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (falseResultPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> exceptionPolicy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (circuitBreakerPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Interesting new usage: var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (timeoutTryPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> circuitBreakerPolicy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Interesting new usage: var policy = retry.WrapAsync(timeoutPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (timeoutPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> retry:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policy = retry.WrapAsync(timeoutPolicy);
Interesting new usage: var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallbackPolicyStream, timeoutPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> warpStream:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Interesting new usage: var policies = timeout.WrapAsync(retry);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (retry):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> timeout:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policies:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policies = timeout.WrapAsync(retry);
Interesting new usage: var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (retryPolicy, circuitBreakerPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> wrap:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Interesting new usage: var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (cachePolicy, retryPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> meteoPolicy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Interesting new usage: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (circuitBreaker):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().FallbackAsync(cacheFunction):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(circuitBreaker);
Interesting new usage: var policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (_circuitBreaker):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().FallbackAsync(cacheFunction):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policy = Policy.Handle < Exception >().FallbackAsync(cacheFunction).WrapAsync(_circuitBreaker);
Interesting new usage: var fallbackbulk = Policy.WrapAsync(fallback2, bulk);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallback2, bulk):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> fallbackbulk:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > fallbackbulk = Policy.WrapAsync(fallback2, bulk);
Interesting new usage: var fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallback, retry, breakPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> fallbackBreak:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > fallbackBreak = Policy.WrapAsync(fallback, retry, breakPolicy);
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (circuitBreakerPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(config.NumberOfRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry).WrapAsync(circuitBreakerPolicy);
Interesting new usage: var policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5))):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount):InvocationExpression
Log: Subsititution: wrap:IdentifierToken -> policies:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policies = HttpPolicyExtensions.HandleTransientHttpError().RetryAsync(retryCount).WrapAsync(HttpPolicyExtensions.HandleTransientHttpError().CircuitBreakerAsync(exceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(5)));
Interesting new usage: var policyWary = Policy.WrapAsync(policyRetry, policyBreak);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (policyRetry, policyBreak):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policyWary:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policyWary = Policy.WrapAsync(policyRetry, policyBreak);
Interesting new usage: var wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallbackPolicy, retryPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> wrapOfRetryAndFallback:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > wrapOfRetryAndFallback = Policy.WrapAsync(fallbackPolicy, retryPolicy);
Interesting new usage: var policy = Policy.WrapAsync(fallback, breaker);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (fallback, breaker):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policy = Policy.WrapAsync(fallback, breaker);
Interesting new usage: var policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (retryPolicy, chaosPolicy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> Policy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> policyWrap:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > policyWrap = Policy.WrapAsync(retryPolicy, chaosPolicy);
Interesting new usage: var retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: Subsititution: (innerHandlingDBZE):ArgumentList -> (policy):ArgumentList
Log: Subsititution: outerHandlingANE:IdentifierName -> fallBackpolicy:IdentifierName
Log: Subsititution: wrap:IdentifierToken -> retryWithFallback:IdentifierToken
Log: Subsititution: AsyncPolicyWrap < ResultPrimitive >:GenericName -> var:IdentifierName
Correponding input: PolicyWrap < ResultPrimitive > retryWithFallback = fallBackpolicy.WrapAsync(policy);
Log: Input to synthesize the program:
Log: PolicyWrap < ResultPrimitive > policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: ---------------------
Log: var policyWrap = Policy.WrapAsync(CreatePolicies().ToArray());
Log: PolicyWrap < ResultPrimitive > setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: ---------------------
Log: var setup = Policy.WrapAsync(waitAndRetryPolicyForError596, waitAndRetryPolicy);
Log: PolicyWrap < ResultPrimitive > policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: ---------------------
Log: var policy = exceptionPolicy.WrapAsync(falseResultPolicy);
Log: PolicyWrap < ResultPrimitive > waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: ---------------------
Log: var waitAndRetryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry : OnRetry).WrapAsync(circuitBreakerPolicy);
Log: PolicyWrap < ResultPrimitive > circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: ---------------------
Log: var circuitBreakerPolicy = Policy.Handle < Exception >().CircuitBreakerAsync(config.NumberOfExceptionsAllowedBeforeBreaking, TimeSpan.FromSeconds(config.DurationOfBreakInSeconds), OnBreak, OnReset).WrapAsync(timeoutTryPolicy);
Log: PolicyWrap < ResultPrimitive > policy = retry.WrapAsync(timeoutPolicy);
Log: ---------------------
Log: var policy = retry.WrapAsync(timeoutPolicy);
Log: PolicyWrap < ResultPrimitive > warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: ---------------------
Log: var warpStream = Policy.WrapAsync(fallbackPolicyStream, timeoutPolicy);
Log: PolicyWrap < ResultPrimitive > policies = timeout.WrapAsync(retry);
Log: ---------------------
Log: var policies = timeout.WrapAsync(retry);
Log: PolicyWrap < ResultPrimitive > wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: ---------------------
Log: var wrap = Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
Log: PolicyWrap < ResultPrimitive > meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: ---------------------
Log: var meteoPolicy = Policy.WrapAsync(cachePolicy, retryPolicy);
Log: predict is var wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
Log: output  is AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
Log: ----------------------------------------------------
Log: old usage is var policy = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
Log: predict is null
Log: old usage is var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
Log: predict is null
Log: old usage is PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: predict is null
Log: old usage is var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: predict is null
Log: old usage is PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: predict is null
Log: old usage is var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
Log: predict is null
Log: old usage is var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
Log: predict is null
Log: old usage is var retryAndBreak = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
Log: predict is null
total correct cases : 0 totalTestCases 1 Successful rate is 0
The successful rate for transforming old usages: 2 / 18
