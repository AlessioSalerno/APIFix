load 197 relevant edits!
load 767 relevant usages
load 1600 relevant usages
invoke synthesis engine...
old usage sise 767, new usage size 100
the size of unRolledEdits is: 63
number of new usages: 100
add subtree faultPolicy.Execute(ctx => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
add subtree _collapserSyncPolicy.Execute((context) => { Ttl ttl = new Ttl(_defaultCacheDuration); _pollySyncCacheProvider.Put(key, itemInWrapper, ttl); }, new Context(key))
add subtree policy.Execute(ctx => { Console.WriteLine("Execute计算" + i); return i * 2; }, context)
add subtree p.Execute(() => { return 1 + 1; }, 5)
add subtree p.Execute(() => { return 1 + 1; }, 5)
add subtree policy.Execute(ct => { var response = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); progress.Report(ProgressWithMessage("Response : " + response, Color.Green)); eventualSuccesses ++; }, cancellationToken)
add subtree policy.Execute(ct => { var response = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); progress.Report(ProgressWithMessage("Response : " + response, Color.Green)); eventualSuccesses ++; }, cancellationToken)
add subtree policy.Execute(ct => { var response = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); progress.Report(ProgressWithMessage("Response : " + response, Color.Green)); eventualSuccesses ++; }, cancellationToken)
add subtree policy.Execute(ct => { var msg = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests.ToString()); progress.Report(ProgressWithMessage("Response : " + msg, Color.Green)); eventualSuccesses ++; }, cancellationToken)
add subtree policy.Execute(ct => { var msg = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); progress.Report(ProgressWithMessage("Response : " + msg, Color.Green)); eventualSuccesses ++; }, cancellationToken)
add subtree waitAndRetryPolicy.Execute(ct => { var response = circuitBreakerPolicy.Execute < string >(() => { return client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); }); watch.Stop(); progress.Report(ProgressWithMessage("Response : " + response + " (after " + watch.ElapsedMilliseconds + "ms)", Color.Green)); eventualSuccesses ++; }, cancellationToken)
add subtree policyWrap.Execute(ct => client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests), cancellationToken)
add subtree policyWrap.Execute(ct => client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests), cancellationToken)
add subtree policy.Execute(() => service.DoSomethingCrucial(7), context)
add subtree retry3Policy.Execute(() => { if(timesTried >= 2) { return; } timesTried ++; throw new TimeoutException(); }, contextData : new Dictionary < string, object > { { nameof(result), result } })
add subtree retryAndWaitPolicy.Execute(() => { if(tryAttempts ++ < 3) { throw new DivideByZeroException(); } }, new Dictionary < string, object > { { nameof(AttemptLog), AttemptLog } })
add subtree faultPolicy.Execute(ctx => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
add subtree faultPolicy.Execute(() => { PersistShares(shares); }, context)
add subtree faultPolicy.Execute(ctx => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
add subtree faultPolicy.Execute(() => { PersistShares(shares); }, context)
add subtree faultPolicy.Execute(() => { PersistShares(shares); }, context)
============== Cluster start ==============
b.Execute(() => { }, contextPassedToExecute)
----------------
b.Execute(ctx => { }, contextPassedToExecute)

cache.Execute(() => { delegateExecuted = true; return valueToReturnFromExecution; }, contextToExecute)
----------------
cache.Execute(ctx => { delegateExecuted = true; return valueToReturnFromExecution; }, contextToExecute)

cache.Execute(() => { return valueToReturn; }, contextToExecute)
----------------
cache.Execute(ctx => { return valueToReturn; }, contextToExecute)

breaker.Execute(() => { }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
----------------
breaker.Execute(ctx => { }, new { key1 = "value1", key2 = "value2" }.AsDictionary())

breaker.Execute(() => { }, new { key = "new_value" }.AsDictionary())
----------------
breaker.Execute(ctx => { }, new { key = "new_value" }.AsDictionary())

p.Execute(() => { throw new ArgumentNullException(); }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
----------------
p.Execute(ctx => { throw new ArgumentNullException(); }, new { key1 = "value1", key2 = "value2" }.AsDictionary())

p.Execute(() => { throw new ArgumentNullException(); }, new { key = "value1" }.AsDictionary())
----------------
p.Execute(ctx => { throw new ArgumentNullException(); }, new { key = "value1" }.AsDictionary())

fallbackPolicy.Execute(() => { return ResultPrimitive.Fault; }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
----------------
fallbackPolicy.Execute(ctx => { return ResultPrimitive.Fault; }, new { key1 = "value1", key2 = "value2" }.AsDictionary())

fallbackPolicy.Execute(() => { return ResultPrimitive.Fault; }, new { key = "value1" }.AsDictionary())
----------------
fallbackPolicy.Execute(ctx => { return ResultPrimitive.Fault; }, new { key = "value1" }.AsDictionary())

policy.Execute(() => { if(counter < numberOfTimesToRaiseException) { counter ++; var exception = new TException(); if(configureException != null) { configureException(exception, counter); } throw exception; } }, contextData)
----------------
policy.Execute(ctx => { if(counter < numberOfTimesToRaiseException) { counter ++; var exception = new TException(); if(configureException != null) { configureException(exception, counter); } throw exception; } }, contextData)

policy.Execute(() => { if(! enumerator.MoveNext()) { throw new ArgumentOutOfRangeException("resultsToRaise", "Not enough TResult values in resultsToRaise."); } return enumerator.Current; }, contextData)
----------------
policy.Execute(ctx => { if(! enumerator.MoveNext()) { throw new ArgumentOutOfRangeException("resultsToRaise", "Not enough TResult values in resultsToRaise."); } return enumerator.Current; }, contextData)

p.Execute(() => { },(IDictionary < string, object >) null)
----------------
p.Execute(ctx => { },(IDictionary < string, object >) null)

p.Execute(() => { },(Context) null)
----------------
p.Execute(ctx => { },(Context) null)

p.Execute(() => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, contextPassedToExecute)
----------------
p.Execute(ctx => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, contextPassedToExecute)

p.Execute(() => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, context)
----------------
p.Execute(ctx => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, context)

new usages: faultPolicy.Execute(ctx => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
old usages: p.Execute(() => { return 1 + 1; }, 5)
old usages: p.Execute(() => { return 1 + 1; }, 5)
old usages: policy.Execute(() => service.DoSomethingCrucial(7), context)
old usages: retry3Policy.Execute(() => { if(timesTried >= 2) { return; } timesTried ++; throw new TimeoutException(); }, contextData : new Dictionary < string, object > { { nameof(result), result } })
old usages: retryAndWaitPolicy.Execute(() => { if(tryAttempts ++ < 3) { throw new DivideByZeroException(); } }, new Dictionary < string, object > { { nameof(AttemptLog), AttemptLog } })
old usages: faultPolicy.Execute(() => { PersistShares(shares); }, context)
old usages: faultPolicy.Execute(() => { PersistShares(shares); }, context)
old usages: faultPolicy.Execute(() => { PersistShares(shares); }, context)
============= Cluster end ==============

generalized output is: hole.Execute(ctx => hole, hole)
Interesting new usage: faultPolicy.Execute(ctx => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
Subsititution: contextPassedToExecute -> context
Subsititution: { } -> PersistShares((IList < Share >) ctx[PolicyContextKeyShares])
Subsititution: b -> faultPolicy
Correponding input: faultPolicy.Execute(() => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
Input to synthesize the program:
b.Execute(() => { }, contextPassedToExecute)
---------------------
b.Execute(ctx => { }, contextPassedToExecute)
cache.Execute(() => { delegateExecuted = true; return valueToReturnFromExecution; }, contextToExecute)
---------------------
cache.Execute(ctx => { delegateExecuted = true; return valueToReturnFromExecution; }, contextToExecute)
faultPolicy.Execute(() => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
---------------------
faultPolicy.Execute(ctx => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
predict is cache.Execute(ctx => { return valueToReturn; }, contextToExecute)
output  is cache.Execute(ctx => { return valueToReturn; }, contextToExecute)
----------------------------------------------------
predict is breaker.Execute(ctx => { }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
output  is breaker.Execute(ctx => { }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
----------------------------------------------------
predict is breaker.Execute(ctx => { }, new { key = "new_value" }.AsDictionary())
output  is breaker.Execute(ctx => { }, new { key = "new_value" }.AsDictionary())
----------------------------------------------------
predict is p.Execute(ctx => { throw new ArgumentNullException(); }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
output  is p.Execute(ctx => { throw new ArgumentNullException(); }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
----------------------------------------------------
predict is p.Execute(ctx => { throw new ArgumentNullException(); }, new { key = "value1" }.AsDictionary())
output  is p.Execute(ctx => { throw new ArgumentNullException(); }, new { key = "value1" }.AsDictionary())
----------------------------------------------------
predict is fallbackPolicy.Execute(ctx => { return ResultPrimitive.Fault; }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
output  is fallbackPolicy.Execute(ctx => { return ResultPrimitive.Fault; }, new { key1 = "value1", key2 = "value2" }.AsDictionary())
----------------------------------------------------
predict is fallbackPolicy.Execute(ctx => { return ResultPrimitive.Fault; }, new { key = "value1" }.AsDictionary())
output  is fallbackPolicy.Execute(ctx => { return ResultPrimitive.Fault; }, new { key = "value1" }.AsDictionary())
----------------------------------------------------
predict is policy.Execute(ctx => { if(counter < numberOfTimesToRaiseException) { counter ++; var exception = new TException(); if(configureException != null) { configureException(exception, counter); } throw exception; } }, contextData)
output  is policy.Execute(ctx => { if(counter < numberOfTimesToRaiseException) { counter ++; var exception = new TException(); if(configureException != null) { configureException(exception, counter); } throw exception; } }, contextData)
----------------------------------------------------
predict is policy.Execute(ctx => { if(! enumerator.MoveNext()) { throw new ArgumentOutOfRangeException("resultsToRaise", "Not enough TResult values in resultsToRaise."); } return enumerator.Current; }, contextData)
output  is policy.Execute(ctx => { if(! enumerator.MoveNext()) { throw new ArgumentOutOfRangeException("resultsToRaise", "Not enough TResult values in resultsToRaise."); } return enumerator.Current; }, contextData)
----------------------------------------------------
predict is p.Execute(ctx => { },(IDictionary < string, object >) null)
output  is p.Execute(ctx => { },(IDictionary < string, object >) null)
----------------------------------------------------
predict is p.Execute(ctx => { },(Context) null)
output  is p.Execute(ctx => { },(Context) null)
----------------------------------------------------
predict is p.Execute(ctx => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, contextPassedToExecute)
output  is p.Execute(ctx => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, contextPassedToExecute)
----------------------------------------------------
predict is p.Execute(ctx => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, context)
output  is p.Execute(ctx => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, context)
----------------------------------------------------
old usage is p.Execute(() => { return 1 + 1; }, 5)
predict is p.Execute(ctx => { return 1 + 1; }, 5)
old usage is p.Execute(() => { return 1 + 1; }, 5)
predict is p.Execute(ctx => { return 1 + 1; }, 5)
old usage is policy.Execute(() => service.DoSomethingCrucial(7), context)
predict is policy.Execute(ctx => service.DoSomethingCrucial(7), context)
old usage is retry3Policy.Execute(() => { if(timesTried >= 2) { return; } timesTried ++; throw new TimeoutException(); }, contextData : new Dictionary < string, object > { { nameof(result), result } })
predict is retry3Policy.Execute(ctx => { if(timesTried >= 2) { return; } timesTried ++; throw new TimeoutException(); }, contextData : new Dictionary < string, object > { { nameof(result), result } })
old usage is retryAndWaitPolicy.Execute(() => { if(tryAttempts ++ < 3) { throw new DivideByZeroException(); } }, new Dictionary < string, object > { { nameof(AttemptLog), AttemptLog } })
predict is retryAndWaitPolicy.Execute(ctx => { if(tryAttempts ++ < 3) { throw new DivideByZeroException(); } }, new Dictionary < string, object > { { nameof(AttemptLog), AttemptLog } })
old usage is faultPolicy.Execute(() => { PersistShares(shares); }, context)
predict is faultPolicy.Execute(ctx => { PersistShares(shares); }, context)
old usage is faultPolicy.Execute(() => { PersistShares(shares); }, context)
predict is faultPolicy.Execute(ctx => { PersistShares(shares); }, context)
old usage is faultPolicy.Execute(() => { PersistShares(shares); }, context)
predict is faultPolicy.Execute(ctx => { PersistShares(shares); }, context)
============== Cluster start ==============
b.Execute(() => 1, contextPassedToExecute)
----------------
b.Execute(ctx => 1, contextPassedToExecute)

p.Execute(() => 2,(IDictionary < string, object >) null)
----------------
p.Execute(ctx => 2,(IDictionary < string, object >) null)

p.Execute(() => 2,(Context) null)
----------------
p.Execute(ctx => 2,(Context) null)

============= Cluster end ==============

Input to synthesize the program:
b.Execute(() => 1, contextPassedToExecute)
---------------------
b.Execute(ctx => 1, contextPassedToExecute)
p.Execute(() => 2,(IDictionary < string, object >) null)
---------------------
p.Execute(ctx => 2,(IDictionary < string, object >) null)
predict is p.Execute(ctx => 2,(Context) null)
output  is p.Execute(ctx => 2,(Context) null)
----------------------------------------------------
============== Cluster start ==============
cache.Execute(() => { delegateExecuted = true; return valueToReturnFromExecution; }, new Context(executionKey))
----------------
cache.Execute(ctx => { delegateExecuted = true; return valueToReturnFromExecution; }, new Context(operationKey))

cache.Execute(() => { return valueToReturn; }, new Context(executionKey))
----------------
cache.Execute(ctx => { return valueToReturn; }, new Context(operationKey))

wrap.Execute(() => { delegateExecuted = true; return valueToReturnFromExecution; }, new Context(executionKey))
----------------
wrap.Execute(ctx => { delegateExecuted = true; return valueToReturnFromExecution; }, new Context(operationKey))

retry.Execute(() => { if(firstExecution) { firstExecution = false; throw new Exception(); } }, new Context(executionKey))
----------------
retry.Execute(ctx => { if(firstExecution) { firstExecution = false; throw new Exception(); } }, new Context(operationKey))

retry.Execute(() => { if(firstExecution) { firstExecution = false; return ResultPrimitive.Fault; } return ResultPrimitive.Good; }, new Context(executionKey))
----------------
retry.Execute(ctx => { if(firstExecution) { firstExecution = false; return ResultPrimitive.Fault; } return ResultPrimitive.Good; }, new Context(operationKey))

============= Cluster end ==============

Input to synthesize the program:
cache.Execute(() => { delegateExecuted = true; return valueToReturnFromExecution; }, new Context(executionKey))
---------------------
cache.Execute(ctx => { delegateExecuted = true; return valueToReturnFromExecution; }, new Context(operationKey))
cache.Execute(() => { return valueToReturn; }, new Context(executionKey))
---------------------
cache.Execute(ctx => { return valueToReturn; }, new Context(operationKey))
predict is wrap.Execute(ctx => { delegateExecuted = true; return valueToReturnFromExecution; }, new Context(operationKey))
output  is wrap.Execute(ctx => { delegateExecuted = true; return valueToReturnFromExecution; }, new Context(operationKey))
----------------------------------------------------
predict is retry.Execute(() => { if(firstExecution) { firstExecution = false; throw new Exception(); } }, new Context(operationKey))
output  is retry.Execute(ctx => { if(firstExecution) { firstExecution = false; throw new Exception(); } }, new Context(operationKey))
----------------------------------------------------
predict is retry.Execute(() => { if(firstExecution) { firstExecution = false; return ResultPrimitive.Fault; } return ResultPrimitive.Good; }, new Context(operationKey))
output  is retry.Execute(ctx => { if(firstExecution) { firstExecution = false; return ResultPrimitive.Fault; } return ResultPrimitive.Good; }, new Context(operationKey))
----------------------------------------------------
============== Cluster start ==============
cache.Execute(() => { return valueToReturn; }, new Context(executionKey)).Should().Be(valueToReturn);
----------------
cache.Execute(ctx => { return valueToReturn; }, new Context(operationKey)).Should().Be(valueToReturn);

============= Cluster end ==============

============== Cluster start ==============
cache.Execute(func, new Context(executionKey))
----------------
cache.Execute(func, new Context(operationKey))

cache.Execute(action, new Context(executionKey))
----------------
cache.Execute(action, new Context(operationKey))

new usages: _collapserSyncPolicy.Execute((context) => { Ttl ttl = new Ttl(_defaultCacheDuration); _pollySyncCacheProvider.Put(key, itemInWrapper, ttl); }, new Context(key))
============= Cluster end ==============

generalized output is: cache.Execute(hole, new Context(operationKey))
Interesting new usage: _collapserSyncPolicy.Execute((context) => { Ttl ttl = new Ttl(_defaultCacheDuration); _pollySyncCacheProvider.Put(key, itemInWrapper, ttl); }, new Context(key))
Subsititution: operationKey -> key
Subsititution: func -> (context) => { Ttl ttl = new Ttl(_defaultCacheDuration); _pollySyncCacheProvider.Put(key, itemInWrapper, ttl); }
Subsititution: cache -> _collapserSyncPolicy
Correponding input: _collapserSyncPolicy.Execute((context) => { Ttl ttl = new Ttl(_defaultCacheDuration); _pollySyncCacheProvider.Put(key, itemInWrapper, ttl); }, new Context(executionKey))
Input to synthesize the program:
cache.Execute(func, new Context(executionKey))
---------------------
cache.Execute(func, new Context(operationKey))
cache.Execute(action, new Context(executionKey))
---------------------
cache.Execute(action, new Context(operationKey))
_collapserSyncPolicy.Execute((context) => { Ttl ttl = new Ttl(_defaultCacheDuration); _pollySyncCacheProvider.Put(key, itemInWrapper, ttl); }, new Context(executionKey))
---------------------
_collapserSyncPolicy.Execute((context) => { Ttl ttl = new Ttl(_defaultCacheDuration); _pollySyncCacheProvider.Put(key, itemInWrapper, ttl); }, new Context(key))
============== Cluster start ==============
cache.Execute(func, new Context(executionKey)).Should().Be(valueToReturn);
----------------
cache.Execute(func, new Context(operationKey)).Should().Be(valueToReturn);

============= Cluster end ==============

============== Cluster start ==============
cache.Execute(action, new Context(executionKey));
----------------
cache.Execute(action, new Context(operationKey));

============= Cluster end ==============

============== Cluster start ==============
cache.Execute(func, new Context(executionKey), tokenSource.Token).Should().Be(valueToReturn);
----------------
cache.Execute(func, new Context(operationKey), tokenSource.Token).Should().Be(valueToReturn);

============= Cluster end ==============

============== Cluster start ==============
cache.Execute(func, new Context(executionKey), tokenSource.Token)
----------------
cache.Execute(func, new Context(operationKey), tokenSource.Token)

policy.Execute(func, new Context(executionKey), tokenSource.Token)
----------------
policy.Execute(func, new Context(operationKey), tokenSource.Token)

============= Cluster end ==============

Input to synthesize the program:
cache.Execute(func, new Context(executionKey), tokenSource.Token)
---------------------
cache.Execute(func, new Context(operationKey), tokenSource.Token)
policy.Execute(func, new Context(executionKey), tokenSource.Token)
---------------------
policy.Execute(func, new Context(operationKey), tokenSource.Token)
============== Cluster start ==============
cache.Invoking(policy => policy.Execute(func, new Context(executionKey), tokenSource.Token)).ShouldThrow < OperationCanceledException >();
----------------
cache.Invoking(policy => policy.Execute(func, new Context(operationKey), tokenSource.Token)).ShouldThrow < OperationCanceledException >();

============= Cluster end ==============

============== Cluster start ==============
cache.Execute(() => { return valueToReturn; }, contextToExecute).Should().Be(valueToReturn);
----------------
cache.Execute(ctx => { return valueToReturn; }, contextToExecute).Should().Be(valueToReturn);

fallbackPolicy.Execute(() => { return ResultPrimitive.Fault; }, new { key = "value1" }.AsDictionary()).Should().Be(ResultPrimitive.Substitute);
----------------
fallbackPolicy.Execute(ctx => { return ResultPrimitive.Fault; }, new { key = "value1" }.AsDictionary()).Should().Be(ResultPrimitive.Substitute);

fallbackPolicy.Execute(() => { return ResultPrimitive.FaultAgain; }, new { key = "value2" }.AsDictionary()).Should().Be(ResultPrimitive.Substitute);
----------------
fallbackPolicy.Execute(ctx => { return ResultPrimitive.FaultAgain; }, new { key = "value2" }.AsDictionary()).Should().Be(ResultPrimitive.Substitute);

============= Cluster end ==============

Input to synthesize the program:
cache.Execute(() => { return valueToReturn; }, contextToExecute).Should().Be(valueToReturn);
---------------------
cache.Execute(ctx => { return valueToReturn; }, contextToExecute).Should().Be(valueToReturn);
fallbackPolicy.Execute(() => { return ResultPrimitive.Fault; }, new { key = "value1" }.AsDictionary()).Should().Be(ResultPrimitive.Substitute);
---------------------
fallbackPolicy.Execute(ctx => { return ResultPrimitive.Fault; }, new { key = "value1" }.AsDictionary()).Should().Be(ResultPrimitive.Substitute);
predict is fallbackPolicy.Execute(ctx => { return ResultPrimitive.FaultAgain; }, new { key = "value2" }.AsDictionary()).Should().Be(ResultPrimitive.Substitute);
output  is fallbackPolicy.Execute(ctx => { return ResultPrimitive.FaultAgain; }, new { key = "value2" }.AsDictionary()).Should().Be(ResultPrimitive.Substitute);
----------------------------------------------------
============== Cluster start ==============
breaker.Execute(() => ResultPrimitive.Good, new { key1 = "value1", key2 = "value2" }.AsDictionary())
----------------
breaker.Execute(ctx => ResultPrimitive.Good, new { key1 = "value1", key2 = "value2" }.AsDictionary())

breaker.Execute(() => ResultPrimitive.Good, new { key = "new_value" }.AsDictionary())
----------------
breaker.Execute(ctx => ResultPrimitive.Good, new { key = "new_value" }.AsDictionary())

p.Execute(() => ResultPrimitive.Good,(IDictionary < string, object >) null)
----------------
p.Execute(ctx => ResultPrimitive.Good,(IDictionary < string, object >) null)

p.Execute(() => ResultPrimitive.Good,(Context) null)
----------------
p.Execute(ctx => ResultPrimitive.Good,(Context) null)

============= Cluster end ==============

Input to synthesize the program:
breaker.Execute(() => ResultPrimitive.Good, new { key1 = "value1", key2 = "value2" }.AsDictionary())
---------------------
breaker.Execute(ctx => ResultPrimitive.Good, new { key1 = "value1", key2 = "value2" }.AsDictionary())
breaker.Execute(() => ResultPrimitive.Good, new { key = "new_value" }.AsDictionary())
---------------------
breaker.Execute(ctx => ResultPrimitive.Good, new { key = "new_value" }.AsDictionary())
predict is p.Execute(ctx => ResultPrimitive.Good,(IDictionary < string, object >) null)
output  is p.Execute(ctx => ResultPrimitive.Good,(IDictionary < string, object >) null)
----------------------------------------------------
predict is p.Execute(ctx => ResultPrimitive.Good,(Context) null)
output  is p.Execute(ctx => ResultPrimitive.Good,(Context) null)
----------------------------------------------------
============== Cluster start ==============
fallbackPolicy.Invoking(p => p.Execute(() => { throw new ArgumentNullException(); }, new { key = "value1" }.AsDictionary())).ShouldNotThrow();
----------------
fallbackPolicy.Invoking(p => p.Execute(ctx => { throw new ArgumentNullException(); }, new { key = "value1" }.AsDictionary())).ShouldNotThrow();

fallbackPolicy.Invoking(p => p.Execute(() => { throw new DivideByZeroException(); }, new { key = "value2" }.AsDictionary())).ShouldNotThrow();
----------------
fallbackPolicy.Invoking(p => p.Execute(ctx => { throw new DivideByZeroException(); }, new { key = "value2" }.AsDictionary())).ShouldNotThrow();

============= Cluster end ==============

Input to synthesize the program:
fallbackPolicy.Invoking(p => p.Execute(() => { throw new ArgumentNullException(); }, new { key = "value1" }.AsDictionary())).ShouldNotThrow();
---------------------
fallbackPolicy.Invoking(p => p.Execute(ctx => { throw new ArgumentNullException(); }, new { key = "value1" }.AsDictionary())).ShouldNotThrow();
fallbackPolicy.Invoking(p => p.Execute(() => { throw new DivideByZeroException(); }, new { key = "value2" }.AsDictionary())).ShouldNotThrow();
---------------------
fallbackPolicy.Invoking(p => p.Execute(ctx => { throw new DivideByZeroException(); }, new { key = "value2" }.AsDictionary())).ShouldNotThrow();
============== Cluster start ==============
policy.Execute(ct => { onExecute(); counter ++; if(! enumerator.MoveNext()) { throw new ArgumentOutOfRangeException(nameof(resultsToRaise), "Not enough TResult values in resultsToRaise."); } if(scenario.AttemptDuringWhichToCancel.HasValue && counter >= scenario.AttemptDuringWhichToCancel.Value) { cancellationTokenSource.Cancel(); } if(scenario.ActionObservesCancellation) { ct.ThrowIfCancellationRequested(); } return enumerator.Current; }, cancellationToken)
----------------
policy.Execute(ct => { onExecute(); counter ++; if(! enumerator.MoveNext()) { throw new ArgumentOutOfRangeException(nameof(resultsToRaise), $"Not enough { typeof(TResult).Name}  values in { nameof(resultsToRaise)}."); } if(scenario.AttemptDuringWhichToCancel.HasValue && counter >= scenario.AttemptDuringWhichToCancel.Value) { cancellationTokenSource.Cancel(); } if(scenario.ActionObservesCancellation) { ct.ThrowIfCancellationRequested(); } return enumerator.Current; }, cancellationToken)

============= Cluster end ==============

============== Cluster start ==============
retry.Execute(() => { if(firstExecution) { firstExecution = false; throw new Exception(); } }, new Context(executionKey));
----------------
retry.Execute(ctx => { if(firstExecution) { firstExecution = false; throw new Exception(); } }, new Context(operationKey));

retry.Execute(() => { if(firstExecution) { firstExecution = false; return ResultPrimitive.Fault; } return ResultPrimitive.Good; }, new Context(executionKey));
----------------
retry.Execute(ctx => { if(firstExecution) { firstExecution = false; return ResultPrimitive.Fault; } return ResultPrimitive.Good; }, new Context(operationKey));

============= Cluster end ==============

Input to synthesize the program:
retry.Execute(() => { if(firstExecution) { firstExecution = false; throw new Exception(); } }, new Context(executionKey));
---------------------
retry.Execute(ctx => { if(firstExecution) { firstExecution = false; throw new Exception(); } }, new Context(operationKey));
retry.Execute(() => { if(firstExecution) { firstExecution = false; return ResultPrimitive.Fault; } return ResultPrimitive.Good; }, new Context(executionKey));
---------------------
retry.Execute(ctx => { if(firstExecution) { firstExecution = false; return ResultPrimitive.Fault; } return ResultPrimitive.Good; }, new Context(operationKey));
============== Cluster start ==============
retry.Execute < int >(() => { if(firstExecution) { firstExecution = false; throw new Exception(); } return 0; }, new Context(executionKey));
----------------
retry.Execute < int >(ctx => { if(firstExecution) { firstExecution = false; throw new Exception(); } return 0; }, new Context(operationKey));

============= Cluster end ==============

============== Cluster start ==============
p.Execute(ct => { }, userCancellationToken)
----------------
policy.Execute(ct => { SystemClock.Sleep(TimeSpan.FromMilliseconds(500), ct); return ResultPrimitive.Good; }, userCancellationToken)

============= Cluster end ==============

============== Cluster start ==============
p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(timeout), ct), userTokenSource.Token)
----------------
p.Execute(ct => { userTokenSource.Cancel(); ct.ThrowIfCancellationRequested(); }, userTokenSource.Token)

============= Cluster end ==============

============== Cluster start ==============
p.Execute(() => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), contextPassedToExecute)
----------------
p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), contextPassedToExecute)

p.Execute(() => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), context)
----------------
p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), context)

============= Cluster end ==============

Input to synthesize the program:
p.Execute(() => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), contextPassedToExecute)
---------------------
p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), contextPassedToExecute)
p.Execute(() => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), context)
---------------------
p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), context)
============== Cluster start ==============
policy.Invoking(p => p.Execute(() => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), context)).ShouldThrow < TimeoutRejectedException >();
----------------
policy.Invoking(p => p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None), context)).ShouldThrow < TimeoutRejectedException >();

============= Cluster end ==============

============== Cluster start ==============
p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), contextPassedToExecute, userCancellationToken)
----------------
p.Execute((ctx, ct) => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), contextPassedToExecute, userCancellationToken)

p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), context, userCancellationToken)
----------------
p.Execute((ctx, ct) => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), context, userCancellationToken)

============= Cluster end ==============

Input to synthesize the program:
p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), contextPassedToExecute, userCancellationToken)
---------------------
p.Execute((ctx, ct) => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), contextPassedToExecute, userCancellationToken)
p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), context, userCancellationToken)
---------------------
p.Execute((ctx, ct) => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), context, userCancellationToken)
============== Cluster start ==============
policy.Invoking(p => p.Execute(ct => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), context, userCancellationToken)).ShouldThrow < TimeoutRejectedException >();
----------------
policy.Invoking(p => p.Execute((ctx, ct) => SystemClock.Sleep(TimeSpan.FromSeconds(3), ct), context, userCancellationToken)).ShouldThrow < TimeoutRejectedException >();

============= Cluster end ==============

============== Cluster start ==============
p.Execute(_ => SystemClock.Sleep(TimeSpan.FromSeconds(timeout * 2), CancellationToken.None), userTokenSource.Token)
----------------
p.Execute(_ => { userTokenSource.Cancel(); SystemClock.Sleep(TimeSpan.FromSeconds(timeout * 2), CancellationToken.None); }, userTokenSource.Token)

old usages: policy.Execute(ctx => { Console.WriteLine("Execute计算" + i); return i * 2; }, context)
old usages: policy.Execute(ct => { var response = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); progress.Report(ProgressWithMessage("Response : " + response, Color.Green)); eventualSuccesses ++; }, cancellationToken)
old usages: policy.Execute(ct => { var response = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); progress.Report(ProgressWithMessage("Response : " + response, Color.Green)); eventualSuccesses ++; }, cancellationToken)
old usages: policy.Execute(ct => { var response = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); progress.Report(ProgressWithMessage("Response : " + response, Color.Green)); eventualSuccesses ++; }, cancellationToken)
old usages: policy.Execute(ct => { var msg = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests.ToString()); progress.Report(ProgressWithMessage("Response : " + msg, Color.Green)); eventualSuccesses ++; }, cancellationToken)
old usages: policy.Execute(ct => { var msg = client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); progress.Report(ProgressWithMessage("Response : " + msg, Color.Green)); eventualSuccesses ++; }, cancellationToken)
old usages: waitAndRetryPolicy.Execute(ct => { var response = circuitBreakerPolicy.Execute < string >(() => { return client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests); }); watch.Stop(); progress.Report(ProgressWithMessage("Response : " + response + " (after " + watch.ElapsedMilliseconds + "ms)", Color.Green)); eventualSuccesses ++; }, cancellationToken)
old usages: policyWrap.Execute(ct => client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests), cancellationToken)
old usages: policyWrap.Execute(ct => client.DownloadString(Configuration.WEB_API_ROOT + "/api/values/" + totalRequests), cancellationToken)
old usages: faultPolicy.Execute(ctx => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
old usages: faultPolicy.Execute(ctx => PersistShares((IList < Share >) ctx[PolicyContextKeyShares]), context)
============= Cluster end ==============

============== Cluster start ==============
p.Execute(ct => ResultPrimitive.Good, userCancellationToken)
----------------
policy.Execute(ct => { SystemClock.Sleep(TimeSpan.FromMilliseconds(500), ct); return ResultPrimitive.Good; }, userCancellationToken)

============= Cluster end ==============

============== Cluster start ==============
p.Execute(ct => { SystemClock.Sleep(TimeSpan.FromSeconds(timeout), ct); return ResultPrimitive.WhateverButTooLate; }, userTokenSource.Token)
----------------
p.Execute(ct => { userTokenSource.Cancel(); ct.ThrowIfCancellationRequested(); return ResultPrimitive.WhateverButTooLate; }, userTokenSource.Token)

============= Cluster end ==============

============== Cluster start ==============
policy.Invoking(p => p.Execute(() => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, context)).ShouldThrow < TimeoutRejectedException >();
----------------
policy.Invoking(p => p.Execute(ctx => { SystemClock.Sleep(TimeSpan.FromSeconds(3), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, context)).ShouldThrow < TimeoutRejectedException >();

============= Cluster end ==============

============== Cluster start ==============
p.Execute(ct => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, contextPassedToExecute, userCancellationToken)
----------------
p.Execute((ctx, ct) => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, contextPassedToExecute, userCancellationToken)

p.Execute(ct => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, context, userCancellationToken)
----------------
p.Execute((ctx, ct) => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, context, userCancellationToken)

============= Cluster end ==============

Input to synthesize the program:
p.Execute(ct => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, contextPassedToExecute, userCancellationToken)
---------------------
p.Execute((ctx, ct) => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, contextPassedToExecute, userCancellationToken)
p.Execute(ct => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, context, userCancellationToken)
---------------------
p.Execute((ctx, ct) => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, context, userCancellationToken)
============== Cluster start ==============
policy.Invoking(p => p.Execute(ct => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, context, userCancellationToken)).ShouldThrow < TimeoutRejectedException >();
----------------
policy.Invoking(p => p.Execute((ctx, ct) => { SystemClock.Sleep(TimeSpan.FromSeconds(3), ct); return ResultPrimitive.WhateverButTooLate; }, context, userCancellationToken)).ShouldThrow < TimeoutRejectedException >();

============= Cluster end ==============

============== Cluster start ==============
p.Execute(_ => { SystemClock.Sleep(TimeSpan.FromSeconds(timeout * 2), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, userTokenSource.Token)
----------------
p.Execute(_ => { userTokenSource.Cancel(); SystemClock.Sleep(TimeSpan.FromSeconds(timeout * 2), CancellationToken.None); return ResultPrimitive.WhateverButTooLate; }, userTokenSource.Token)

============= Cluster end ==============

total correct cases : 18 totalTestCases 20Successful rate is 0.9
