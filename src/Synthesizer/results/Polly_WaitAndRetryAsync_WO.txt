Configuration: 
---- UseAdditionalOutput: True
---- UseAdditionalInput : False
---- OnlyNewUsage       : False
---- GivenExample       : 1
---- UseTypedUsage      : False
---- NewKeyWords        : 
---- OldKeyWords        : 
---- OldUsageThreashold : 0.1
---- NewUsageThreashold : 0.25
load 3 relevant edits!
load 867 old relevant usages
load 592 new relevant usages
Log: invoke synthesis engine...
Log: the size of unRolledEdits is: 3
size of new usage: 592
Log: add new usage var arr = new IAsyncPolicy[] { Policy.Handle < HttpRequestException >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount} implemented with Polly's RetryPolicy " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); }), Policy.Handle < HttpRequestException >().CircuitBreakerAsync(_exceptionCountAllowedBeforeBreaking, TimeSpan.FromMinutes(1),(exception, duration) => { _logger.LogTrace("Circuit breaker opened"); },() => { _logger.LogTrace("Circuit breaker reset"); }) };
Log: add new usage var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { });
Log: add new usage var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: add new usage var waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 983 || x.Number == 978).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { _logger.LogInformation(exception, "Open Connection - DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var policy = Policy.HandleResult < LockLeaseResult >(lockLeaseResult => ! lockLeaseResult.Ok).WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(retryAfter));
Log: add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { });
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(NumberOfRetries, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { _logger.LogError($"Could not replicate - exception {exception.Message}"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var falseResultPolicy = Policy.HandleResult(false).WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry());
Log: add new usage var exceptionPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode ==(HttpStatusCode) 429).WaitAndRetryAsync(retryCount : MaxRetries, sleepDurationProvider :(retryCount, response, context) => { return response.Result ?.Headers.RetryAfter.Delta.Value ?? TimeSpan.FromSeconds(30 * retryCount); }, onRetryAsync : async(response, timespan, retryCount, context) => { await Console.Out.WriteLineAsync($"{Environment.NewLine}Waiting {timespan} before retrying (attemp #{retryCount}/{MaxRetries})..."); });
Log: add new usage var retryPolicy = Policy.Handle < AdalServiceException >().WaitAndRetryAsync(MAX_TOKEN_RETRY_ATTEMPTS, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.NotFound).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
Log: add new usage AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Log: add new usage var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var policy = Policy.Handle < Exception >(e => { Console.WriteLine("Tentando obter Token"); return true; }).WaitAndRetryAsync(3, i => TimeSpan.FromTicks(5));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: add new usage var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
Log: add new usage var policy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(x => x.StatusCode == HttpStatusCode.BadRequest).WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
Log: add new usage var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Log: add new usage var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < SoapException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => Logger.Error(exception, "Служба СМС вернула ошибку. Код: {code}. Сообщение: {message}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", exception.HResult, exception.Message, timeSpan, retryCount));
Log: add new usage var waitAndRetryPolicy = Policy.HandleResult < DeliveryStatus >(status => status != DeliveryStatus.Delivered).WaitAndRetryAsync(11, retryAttempt => TimeSpan.FromSeconds(10 * retryAttempt),(result, timeSpan, retryCount, context) => Logger.Info("Сообщение {messageId} для заявки {appId} клиента {userName} не доставлено. Текущий статус отправки {status}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", messageId, applicationId, userName ?? "",((SmsDeliveryStatus) result.Result).GetDescription(), timeSpan, retryCount));
Log: add new usage var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(result, timeSpan, retryCount, context) => Logger.Error(result.Exception, "Запрос к сервису статистики неудачен. Код: {statusCode}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount} {request}", result.Result.StatusCode, timeSpan, retryCount, requestContent));
Log: add new usage var waitAndRetryPolicy = Policy.HandleResult < ClientValidationRequest >(result => result ?.Result ==(int) ClientValidationResult.Requested).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < bool >(result => result == false).WaitAndRetryAsync(RetryCount, i => TimeSpan.FromSeconds(WaitSecondsBeforeRetry));
Log: add new usage AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Log: add new usage var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retriesCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan) => { logger.LogError(exception, $"Operation failed, retrying in {timeSpan.Seconds} seconds"); });
Log: add new usage var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var retryFailedUserPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var policy = Policy.Handle < ResponseException >().Or < ConnectionPoolBusyException >().Or < ServerUnavailableException >().WaitAndRetryAsync(retryCount : 10, sleepDurationProvider :(attempt, exception, context) => { if(exception is ResponseException responseException && responseException.CosmosDbStatusCode() == RetryAfterStatusCode) { return TimeSpan.FromSeconds(5 + 5 * attempt * _jitterer.NextDouble()); } _logger.LogInformation($"Exception {exception.GetType()}. Retry immediately"); return TimeSpan.Zero; }, onRetryAsync :(exception, waitTime, attempt, _) => { totalWaitTime = totalWaitTime.Add(waitTime); retryCount = attempt; if(exception is ResponseException responseException) { var exceptionRu = CosmosResponse.ParseRequestCharge(responseException.StatusAttributes); totalRu += exceptionRu; _logger.LogInformation($"ResponseException cost {exceptionRu}RU"); } if(exception is ConnectionPoolBusyException || exception is ServerUnavailableException) { _logger.LogInformation($"Resetting the GremlinClient after experiencing an '{exception.GetType()}'"); _factory.ClearGraphClient(); } return Task.CompletedTask; });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var retryFailedUserPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: add new usage var policyRegistry = new PolicyRegistry { { RetryPolicyKey.NoRetry.ToString(), Policy.NoOpAsync() }, { RetryPolicyKey.BasicRetryOnRpc.ToString(), Policy.Handle < RpcException >().RetryAsync(MaxRetries,(exception, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithExponentialBackoff.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(Backoff.ExponentialBackoff(TimeSpan.FromSeconds(1), MaxRetries),(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithJitter.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(MaxRetries, retryAttempt => { var backoffSpans = Backoff.DecorrelatedJitterBackoffV2(TimeSpan.FromSeconds(1), MaxRetries).ToList(); return backoffSpans[retryAttempt - 1]; },(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { CachePolicyKey.InMemoryCache.ToString(), Policy.CacheAsync(componentContext.Resolve < IAsyncCacheProvider >(), TimeSpan.FromMinutes(5),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache miss {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put {cacheKey}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get error {cacheKey}; {exception}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put error {cacheKey}; {exception}")) }, { CachePolicyKey.NoCache.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.NoTimeout.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.DefaultPessimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Pessimistic,(context, span, task) => { task.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); console.Out.WriteLine($"Operation {context.OperationKey} timed out."); return Task.CompletedTask; }) }, { TimeoutPolicyKey.DefaultOptimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Optimistic,(context, span, abandonedTask) => { console.Out.WriteLine($"Operation: {context.OperationKey}, timeout after {span}. "); abandonedTask.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); return Task.CompletedTask; }) }, { CircuitBreakerPolicyKey.NoBreaker.ToString(), Policy.NoOpAsync() }, { CircuitBreakerPolicyKey.DefaultCircuitBreaker.ToString(), Policy.Handle < RpcException >().CircuitBreakerAsync(2, TimeSpan.FromSeconds(2),(exception, span) => { console.WriteLine($"Circuit broken. Span: {span}; Exception: {exception.Message};"); },() => { console.WriteLine("Circuit reset."); },() => { console.WriteLine("Circuit half openBa."); }) }, };
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolice = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add new usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxtrys, x => seconds);
Log: add new usage var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.GatewayTimeout || msg.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
Log: add new usage var policy = Policy.Handle < HttpRequestException >().Or < OperationCanceledException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(delayAfterFailure));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(10));
Log: add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(policyConfigs.RetryCount, _ => TimeSpan.FromMilliseconds(policyConfigs.RetryDelayInMs));
Log: add new usage var httpRetryPolicy = Policy.Handle < HttpRequestException >().Or < TaskCanceledException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(RetryRequired).WaitAndRetryAsync(GetBackOff(maxRetries));
Log: add new usage var retryAfterPolicy = Policy.HandleResult < HttpResponseMessage >(ContainsRetryAfterHeader).WaitAndRetryAsync(maxRetries, sleepDurationProvider,(outcome, timespan, retryCount, context) => Task.CompletedTask);
Log: add new usage var retryPolicy = HandleResult().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount, retryAttempt => retryDelay);
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
Log: add new usage AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask; });
Log: add new usage var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask; });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retry = Policy.Handle < Exception >().WaitAndRetryAsync(Backoff.LinearBackoff(TimeSpan.FromSeconds(settings.RetryInitialDelaySeconds), settings.RetryCount),(exception, span, retryCount, context) => { logger.LogError(exception, "{@EventType} {@Realm} {@TimeSpan} {@retryCount}", "Retry", description, span, retryCount); });
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(exception, timeSpan, retryCount, context) => { });
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add new usage var falseResultPolicy = Policy.HandleResult(false).WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry());
Log: add new usage var exceptionPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: add new usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxtrys, x => seconds);
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage IAsyncPolicy < HttpResponseMessage > policy = Policy.Handle < SocketException >().OrTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: add new usage var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: add new usage var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var retry = Policy < HttpResponseMessage >.Handle < Exception >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var policy = Policy.Handle < InvalidOperationException >().Or < Exception >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); });
Log: add new usage var policy = Policy.Handle < InvalidOperationException >().Or < Exception >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add new usage AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask.ConfigureAwait(false); });
Log: add new usage var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask.ConfigureAwait(false); });
Log: add new usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: add new usage var policyRetry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(3, retryTimespan => TimeSpan.FromSeconds(Math.Pow(2, retryTimespan)),(exception, timespan, retryCount, context) => { var msg = $"第 {retryCount} 次进行错误重试 " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); });
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(e => HttpStatusCodeWorthRetry.ToList().Contains((int) e.StatusCode)).WaitAndRetryAsync(MaxRetryCount, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => PolicyLog($"API is throttling our requests automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"));
Log: add new usage var policy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000));
Log: add new usage var policy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000));
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add new usage AsyncRetryPolicy retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var polly = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, pause => TimeSpan.FromSeconds(5));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(_appSettings.RetryAttempt, retryAttempt => TimeSpan.FromMilliseconds(3000));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolicy = Policy.HandleResult < IRestResponse >(x => FindWarning(x) is null && x.StatusCode != HttpStatusCode.NotFound && x.StatusCode != HttpStatusCode.Unauthorized && x.StatusCode != HttpStatusCode.Conflict && x.StatusCode != HttpStatusCode.BadRequest && x.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(retryNumber, retryAttempt => TimeSpan.FromSeconds(retrySleepSeconds));
Log: add new usage var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Trying for the {retryCount} time!"); Console.ForegroundColor = ConsoleColor.White; });
Log: add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
Log: add new usage var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
Log: add new usage var retryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(1),(result, span, retryCount, ctx) => { Console.WriteLine($"Retrying({retryCount})..."); });
Log: add new usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add new usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < Exception >().OrResult < HttpResponseMessage >(res => { return res.StatusCode != System.Net.HttpStatusCode.OK; }).WaitAndRetryAsync(sleepDurations : new[] { TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(200), TimeSpan.FromMilliseconds(300) }, onRetry :(exception, ts, context) => { Console.WriteLine($"polly.retry：exMsg={exception.Exception ?.Message}, {ts.Minutes * 60 + ts.Seconds}"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryWaitPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add new usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add new usage var retryPolicy = Policy.Handle < Exception >((ex) => { logger.Log(LogSeverity.Error,(ex.InnerException != null) ? ex.InnerException.Message : ex.Message + "\r\n GetTrendingStocks retry FAILURE"); return !(ex is Polly.CircuitBreaker.BrokenCircuitException); }).WaitAndRetryAsync(_retryCount, x => TimeSpan.FromMilliseconds(_sleepTimeAfterFail));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var retryPolice = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add new usage var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add new usage var policy = Policy.Handle < SentNotificationException >().WaitAndRetryAsync(_maxRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(3, retryAttempt)));
Log: add new usage var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Log: add new usage var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r =>(int) r.StatusCode == 429).WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add new usage var retryPolicy = Policy.Handle < System.Net.Sockets.SocketException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: add old usage var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
Log: add old usage var retry = Policy.Handle < DbException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnPolicyRetry);
Log: add old usage var retry = Policy.Handle < DbException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry);
Log: add old usage var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
Log: add old usage RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
Log: add old usage IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream = new MemoryStream());
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: add old usage var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
Log: add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
Log: add old usage var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
Log: add old usage var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.StatusCode ==(System.Net.HttpStatusCode) 429) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}")).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.5 * Math.Pow(2, attempt)));
Log: add old usage var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"NotStarted\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Failed\"}")).WaitAndRetryAsync(20, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
Log: add old usage var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: add old usage var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
Log: add old usage IAsyncPolicy AdoRetryPolicy = Policy.Handle < Exception >(ex => true).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 4));
Log: add old usage var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
Log: add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
Log: add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
Log: add old usage var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var authorisation = Policy.HandleResult < ValidatedToken >(_ => ! _.Succeeded).WaitAndRetryAsync(retries, SleepDurationProvider, async(outcome, retryNumber, context) => await actionToRetryOnFailure);
Log: add old usage var policyRetry = Policy.HandleResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(retryWaitsec),(resultPolly, timeSpan, countRetried, context) => { System.Console.WriteLine($"Request failed with {resultPolly.Result.StatusCode}"); });
Log: add old usage var retry = Policy.Handle < HttpRequestException >().Or < Polly.Timeout.TimeoutRejectedException >().OrResult < HttpResponseMessage >(response => { return retriable.Contains((int) response.StatusCode); }).WaitAndRetryAsync(retryCount : 5, sleepDurationProvider :(retryCount, response, context) => { var serverWait = response.Result ?.Headers.RetryAfter ?.Delta; var clientWait =(double) rand.Next(retryBaseDelay,(int) Math.Pow(2, retryCount) * retryMultiplier); var wait = clientWait; if(serverWait.HasValue) { wait = serverWait.Value.TotalMilliseconds + clientWait; } return TimeSpan.FromMilliseconds(wait); }, onRetryAsync :(response, sleepTime, retryCount, content) => Task.CompletedTask);
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var executionPolicy = Policy.Handle < ProvisionedThroughputExceededException >().WaitAndRetryAsync(10000,(retryCount) => TimeSpan.FromMilliseconds(250),(e, t, i, c) => OnRetry(request, e, t, i));
Log: add old usage var retryPolicy = Policy.Handle < RetryNeededException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(retryAttempt), onRetry :(ex, delay, context, tsk) => { Console.WriteLine($"Retrying exception {ex.ToAsyncString()}"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var _httpRequestPolicy = Policy < MovieDetail >.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(additionalRetries, retryAttempt => TimeSpan.FromSeconds(1));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(RetryCount, retryAttemp => RetryWaitTime,(exception, span, context) => { Trace.TraceError($"{DateTime.Now}: Error Sending Message, retry attempt: {span}, error: {exception}"); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
Log: add old usage var retryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(3, j => TimeSpan.FromSeconds(2),(result, timeSpan, retryCount, context) => { client = new HttpClient(); if(retryCount == 1) { client.BaseAddress = new Uri(creditcardServiceBaseAddress_2 + "1"); LoggingFunction("Retry logic: Start with Alternative 1", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 1 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } else { client.BaseAddress = new Uri(creditcardServiceBaseAddress_3); LoggingFunction("Retry logic: Start with Alternative 2", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 2 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } });
Log: add old usage AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Log: add old usage var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < StorageException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
Log: add old usage var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
Log: add old usage var trainRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var addFaceRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var findRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var addRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var matchRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: add old usage var exceptionPolicy = Policy.Handle < HttpRequestException >().Or < WebException >().Or < InvalidOperationException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains((int) r.StatusCode)).OrResult(r => r.IsSuccessStatusCode == false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
Log: add old usage var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var connectPolicy = Policy.HandleResult < bool >(false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: add old usage var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { Console.WriteLine($"Received {exception.GetType()}{exception.Message}"); Console.WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: add old usage var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: add old usage var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(ex, timeSpan) => { Console.WriteLine($"Exception: {ex.Message}"); Console.WriteLine($"Retrying in {timeSpan.Seconds} seconds"); });
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}下载异常，开始下载重试！\r\n{1}", strFileName, exception.Message)); });
Log: add old usage var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
Log: add old usage var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"下载[{downloadUrl}时，发生异常，正在进行重试下载]", Category.Warn, Priority.High); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage Polly.Retry.RetryPolicy < int > politicaWaitAndRetry = Polly.Policy.HandleResult < int >(i => true).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(7) },(e, t, i, c) => ReportPollyError(e, t, i, c));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: add old usage var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: add old usage var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: add old usage var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(exception, timeSpan, retryCount, context) => ManageRetryException(exception, timeSpan, retryCount, context));
Log: add old usage var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: add old usage var retryPolicy = Policy.Handle < Exception >(e => ! cancellationToken.IsCancellationRequested).WaitAndRetryAsync(policyMaxAttempts, attempt => TimeSpan.FromSeconds(retrySeconds),(exception, timeSpan, attempt, context) => { if(attempt == 1) { _log.WriteWarningAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl}. Retry in {retrySeconds} sec.", exception.Message).GetAwaiter().GetResult(); } if(attempt % policyMaxAttempts == 0) { _log.WriteErrorAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl} after {policyMaxAttempts} attempts", exception).GetAwaiter().GetResult(); } });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var retryPolicy = Policy.Handle < ApiConnectionException >().WaitAndRetryAsync(DecorrelatedJitter(50, TimeSpan.FromMilliseconds(250), TimeSpan.FromSeconds(5)), onRetry :(exception, span, count, context) => { Console.WriteLine($"Action failed with error of \"{exception.Message}\". Waiting {span.TotalMilliseconds}ms to retry (#{count})"); });
Log: add old usage var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage IAsyncPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry :(exception, retryTimespan) => Log.Logger.Error(exception, $"Retry count {retryTimespan}"));
Log: add old usage var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(2, retryCount => TimeSpan.FromSeconds(2),(exception, timeSpan, retryCount, context) => { _logger.LogWarning($"Call to {url} failed - Retry {retryCount} : TimeSpan {timeSpan} : Ex {exception.Message}"); });
Log: add old usage var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage Polly.Retry.RetryPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3,(retry) => TimeSpan.FromSeconds(2),(ex, ts, attempt, context) => { logger.LogWarning($"An error occurred in attempt number {attempt} to release message {message.MessageId}" + $" in subscription \"{subscription}\": {ex.GetType().Name + " - " + ex.Message}"); });
Log: add old usage var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: add old usage var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: add old usage var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: add old usage var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: add old usage Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: ============== Cluster start ==============
- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => contextData = context);
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => contextData = context);

- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => capturedContext = context);
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds(),
                    2.Seconds(),
                    3.Seconds()
                }, (_, __, context) => capturedContext = context);

- Policy policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds()
                },
                (_, __, context) => contextValue = context["key"].ToString());
----------------
+ var policy = Policy
                .Handle<DivideByZeroException>()
                .WaitAndRetryAsync(new[]
                {
                    1.Seconds()
                },
                (_, __, context) => contextValue = context["key"].ToString());

new usages: var arr = new IAsyncPolicy[] { Policy.Handle < HttpRequestException >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount} implemented with Polly's RetryPolicy " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); }), Policy.Handle < HttpRequestException >().CircuitBreakerAsync(_exceptionCountAllowedBeforeBreaking, TimeSpan.FromMinutes(1),(exception, duration) => { _logger.LogTrace("Circuit breaker opened"); },() => { _logger.LogTrace("Circuit breaker reset"); }) };
new usages: var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
new usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { });
new usages: var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
new usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
new usages: var waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
new usages: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
new usages: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
new usages: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 983 || x.Number == 978).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { _logger.LogInformation(exception, "Open Connection - DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
new usages: var policy = Policy.HandleResult < LockLeaseResult >(lockLeaseResult => ! lockLeaseResult.Ok).WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(retryAfter));
new usages: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { });
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(NumberOfRetries, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { _logger.LogError($"Could not replicate - exception {exception.Message}"); });
new usages: var falseResultPolicy = Policy.HandleResult(false).WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry());
new usages: var exceptionPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
new usages: var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode ==(HttpStatusCode) 429).WaitAndRetryAsync(retryCount : MaxRetries, sleepDurationProvider :(retryCount, response, context) => { return response.Result ?.Headers.RetryAfter.Delta.Value ?? TimeSpan.FromSeconds(30 * retryCount); }, onRetryAsync : async(response, timespan, retryCount, context) => { await Console.Out.WriteLineAsync($"{Environment.NewLine}Waiting {timespan} before retrying (attemp #{retryCount}/{MaxRetries})..."); });
new usages: var retryPolicy = Policy.Handle < AdalServiceException >().WaitAndRetryAsync(MAX_TOKEN_RETRY_ATTEMPTS, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.NotFound).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
new usages: AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
new usages: var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var policy = Policy.Handle < Exception >(e => { Console.WriteLine("Tentando obter Token"); return true; }).WaitAndRetryAsync(3, i => TimeSpan.FromTicks(5));
new usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
new usages: var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
new usages: var policy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(x => x.StatusCode == HttpStatusCode.BadRequest).WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
new usages: var waitAndRetryPolicy = Policy.Handle < SoapException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => Logger.Error(exception, "Служба СМС вернула ошибку. Код: {code}. Сообщение: {message}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", exception.HResult, exception.Message, timeSpan, retryCount));
new usages: var waitAndRetryPolicy = Policy.HandleResult < DeliveryStatus >(status => status != DeliveryStatus.Delivered).WaitAndRetryAsync(11, retryAttempt => TimeSpan.FromSeconds(10 * retryAttempt),(result, timeSpan, retryCount, context) => Logger.Info("Сообщение {messageId} для заявки {appId} клиента {userName} не доставлено. Текущий статус отправки {status}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", messageId, applicationId, userName ?? "",((SmsDeliveryStatus) result.Result).GetDescription(), timeSpan, retryCount));
new usages: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(result, timeSpan, retryCount, context) => Logger.Error(result.Exception, "Запрос к сервису статистики неудачен. Код: {statusCode}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount} {request}", result.Result.StatusCode, timeSpan, retryCount, requestContent));
new usages: var waitAndRetryPolicy = Policy.HandleResult < ClientValidationRequest >(result => result ?.Result ==(int) ClientValidationResult.Requested).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < bool >(result => result == false).WaitAndRetryAsync(RetryCount, i => TimeSpan.FromSeconds(WaitSecondsBeforeRetry));
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retriesCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan) => { logger.LogError(exception, $"Operation failed, retrying in {timeSpan.Seconds} seconds"); });
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
new usages: var retryFailedUserPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
new usages: var policy = Policy.Handle < ResponseException >().Or < ConnectionPoolBusyException >().Or < ServerUnavailableException >().WaitAndRetryAsync(retryCount : 10, sleepDurationProvider :(attempt, exception, context) => { if(exception is ResponseException responseException && responseException.CosmosDbStatusCode() == RetryAfterStatusCode) { return TimeSpan.FromSeconds(5 + 5 * attempt * _jitterer.NextDouble()); } _logger.LogInformation($"Exception {exception.GetType()}. Retry immediately"); return TimeSpan.Zero; }, onRetryAsync :(exception, waitTime, attempt, _) => { totalWaitTime = totalWaitTime.Add(waitTime); retryCount = attempt; if(exception is ResponseException responseException) { var exceptionRu = CosmosResponse.ParseRequestCharge(responseException.StatusAttributes); totalRu += exceptionRu; _logger.LogInformation($"ResponseException cost {exceptionRu}RU"); } if(exception is ConnectionPoolBusyException || exception is ServerUnavailableException) { _logger.LogInformation($"Resetting the GremlinClient after experiencing an '{exception.GetType()}'"); _factory.ClearGraphClient(); } return Task.CompletedTask; });
new usages: var policyRegistry = new PolicyRegistry { { RetryPolicyKey.NoRetry.ToString(), Policy.NoOpAsync() }, { RetryPolicyKey.BasicRetryOnRpc.ToString(), Policy.Handle < RpcException >().RetryAsync(MaxRetries,(exception, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithExponentialBackoff.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(Backoff.ExponentialBackoff(TimeSpan.FromSeconds(1), MaxRetries),(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithJitter.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(MaxRetries, retryAttempt => { var backoffSpans = Backoff.DecorrelatedJitterBackoffV2(TimeSpan.FromSeconds(1), MaxRetries).ToList(); return backoffSpans[retryAttempt - 1]; },(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { CachePolicyKey.InMemoryCache.ToString(), Policy.CacheAsync(componentContext.Resolve < IAsyncCacheProvider >(), TimeSpan.FromMinutes(5),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache miss {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put {cacheKey}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get error {cacheKey}; {exception}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put error {cacheKey}; {exception}")) }, { CachePolicyKey.NoCache.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.NoTimeout.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.DefaultPessimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Pessimistic,(context, span, task) => { task.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); console.Out.WriteLine($"Operation {context.OperationKey} timed out."); return Task.CompletedTask; }) }, { TimeoutPolicyKey.DefaultOptimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Optimistic,(context, span, abandonedTask) => { console.Out.WriteLine($"Operation: {context.OperationKey}, timeout after {span}. "); abandonedTask.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); return Task.CompletedTask; }) }, { CircuitBreakerPolicyKey.NoBreaker.ToString(), Policy.NoOpAsync() }, { CircuitBreakerPolicyKey.DefaultCircuitBreaker.ToString(), Policy.Handle < RpcException >().CircuitBreakerAsync(2, TimeSpan.FromSeconds(2),(exception, span) => { console.WriteLine($"Circuit broken. Span: {span}; Exception: {exception.Message};"); },() => { console.WriteLine("Circuit reset."); },() => { console.WriteLine("Circuit half openBa."); }) }, };
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
new usages: var retryPolice = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
new usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxtrys, x => seconds);
new usages: var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.GatewayTimeout || msg.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
new usages: var policy = Policy.Handle < HttpRequestException >().Or < OperationCanceledException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(delayAfterFailure));
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(10));
new usages: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(policyConfigs.RetryCount, _ => TimeSpan.FromMilliseconds(policyConfigs.RetryDelayInMs));
new usages: var httpRetryPolicy = Policy.Handle < HttpRequestException >().Or < TaskCanceledException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(RetryRequired).WaitAndRetryAsync(GetBackOff(maxRetries));
new usages: var retryAfterPolicy = Policy.HandleResult < HttpResponseMessage >(ContainsRetryAfterHeader).WaitAndRetryAsync(maxRetries, sleepDurationProvider,(outcome, timespan, retryCount, context) => Task.CompletedTask);
new usages: var retryPolicy = HandleResult().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount, retryAttempt => retryDelay);
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); });
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
new usages: AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask; });
new usages: var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask; });
new usages: var retry = Policy.Handle < Exception >().WaitAndRetryAsync(Backoff.LinearBackoff(TimeSpan.FromSeconds(settings.RetryInitialDelaySeconds), settings.RetryCount),(exception, span, retryCount, context) => { logger.LogError(exception, "{@EventType} {@Realm} {@TimeSpan} {@retryCount}", "Retry", description, span, retryCount); });
new usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(exception, timeSpan, retryCount, context) => { });
new usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
new usages: IAsyncPolicy < HttpResponseMessage > policy = Policy.Handle < SocketException >().OrTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
new usages: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
new usages: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
new usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var retry = Policy < HttpResponseMessage >.Handle < Exception >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
new usages: var policy = Policy.Handle < InvalidOperationException >().Or < Exception >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); });
new usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
new usages: AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask.ConfigureAwait(false); });
new usages: var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask.ConfigureAwait(false); });
new usages: var policyRetry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(3, retryTimespan => TimeSpan.FromSeconds(Math.Pow(2, retryTimespan)),(exception, timespan, retryCount, context) => { var msg = $"第 {retryCount} 次进行错误重试 " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); });
new usages: var waitAndRetryPolicy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(e => HttpStatusCodeWorthRetry.ToList().Contains((int) e.StatusCode)).WaitAndRetryAsync(MaxRetryCount, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => PolicyLog($"API is throttling our requests automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"));
new usages: var policy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000));
new usages: AsyncRetryPolicy retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
new usages: var polly = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, pause => TimeSpan.FromSeconds(5));
new usages: var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(_appSettings.RetryAttempt, retryAttempt => TimeSpan.FromMilliseconds(3000));
new usages: var retryPolicy = Policy.HandleResult < IRestResponse >(x => FindWarning(x) is null && x.StatusCode != HttpStatusCode.NotFound && x.StatusCode != HttpStatusCode.Unauthorized && x.StatusCode != HttpStatusCode.Conflict && x.StatusCode != HttpStatusCode.BadRequest && x.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(retryNumber, retryAttempt => TimeSpan.FromSeconds(retrySleepSeconds));
new usages: var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Trying for the {retryCount} time!"); Console.ForegroundColor = ConsoleColor.White; });
new usages: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
new usages: var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
new usages: var retryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(1),(result, span, retryCount, ctx) => { Console.WriteLine($"Retrying({retryCount})..."); });
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < Exception >().OrResult < HttpResponseMessage >(res => { return res.StatusCode != System.Net.HttpStatusCode.OK; }).WaitAndRetryAsync(sleepDurations : new[] { TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(200), TimeSpan.FromMilliseconds(300) }, onRetry :(exception, ts, context) => { Console.WriteLine($"polly.retry：exMsg={exception.Exception ?.Message}, {ts.Minutes * 60 + ts.Seconds}"); });
new usages: var retryWaitPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
new usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
new usages: var retryPolicy = Policy.Handle < Exception >((ex) => { logger.Log(LogSeverity.Error,(ex.InnerException != null) ? ex.InnerException.Message : ex.Message + "\r\n GetTrendingStocks retry FAILURE"); return !(ex is Polly.CircuitBreaker.BrokenCircuitException); }).WaitAndRetryAsync(_retryCount, x => TimeSpan.FromMilliseconds(_sleepTimeAfterFail));
new usages: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
new usages: var policy = Policy.Handle < SentNotificationException >().WaitAndRetryAsync(_maxRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(3, retryAttempt)));
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r =>(int) r.StatusCode == 429).WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
new usages: var retryPolicy = Policy.Handle < System.Net.Sockets.SocketException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
old usages: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
old usages: var retry = Policy.Handle < DbException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnPolicyRetry);
old usages: var retry = Policy.Handle < DbException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry);
old usages: var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
old usages: RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
old usages: IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream = new MemoryStream());
old usages: var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
old usages: var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
old usages: var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
old usages: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.StatusCode ==(System.Net.HttpStatusCode) 429) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}")).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.5 * Math.Pow(2, attempt)));
old usages: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"NotStarted\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Failed\"}")).WaitAndRetryAsync(20, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
old usages: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
old usages: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
old usages: IAsyncPolicy AdoRetryPolicy = Policy.Handle < Exception >(ex => true).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 4));
old usages: var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
old usages: var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var authorisation = Policy.HandleResult < ValidatedToken >(_ => ! _.Succeeded).WaitAndRetryAsync(retries, SleepDurationProvider, async(outcome, retryNumber, context) => await actionToRetryOnFailure);
old usages: var policyRetry = Policy.HandleResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(retryWaitsec),(resultPolly, timeSpan, countRetried, context) => { System.Console.WriteLine($"Request failed with {resultPolly.Result.StatusCode}"); });
old usages: var retry = Policy.Handle < HttpRequestException >().Or < Polly.Timeout.TimeoutRejectedException >().OrResult < HttpResponseMessage >(response => { return retriable.Contains((int) response.StatusCode); }).WaitAndRetryAsync(retryCount : 5, sleepDurationProvider :(retryCount, response, context) => { var serverWait = response.Result ?.Headers.RetryAfter ?.Delta; var clientWait =(double) rand.Next(retryBaseDelay,(int) Math.Pow(2, retryCount) * retryMultiplier); var wait = clientWait; if(serverWait.HasValue) { wait = serverWait.Value.TotalMilliseconds + clientWait; } return TimeSpan.FromMilliseconds(wait); }, onRetryAsync :(response, sleepTime, retryCount, content) => Task.CompletedTask);
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var executionPolicy = Policy.Handle < ProvisionedThroughputExceededException >().WaitAndRetryAsync(10000,(retryCount) => TimeSpan.FromMilliseconds(250),(e, t, i, c) => OnRetry(request, e, t, i));
old usages: var retryPolicy = Policy.Handle < RetryNeededException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(retryAttempt), onRetry :(ex, delay, context, tsk) => { Console.WriteLine($"Retrying exception {ex.ToAsyncString()}"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var _httpRequestPolicy = Policy < MovieDetail >.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(additionalRetries, retryAttempt => TimeSpan.FromSeconds(1));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(RetryCount, retryAttemp => RetryWaitTime,(exception, span, context) => { Trace.TraceError($"{DateTime.Now}: Error Sending Message, retry attempt: {span}, error: {exception}"); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
old usages: var retryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(3, j => TimeSpan.FromSeconds(2),(result, timeSpan, retryCount, context) => { client = new HttpClient(); if(retryCount == 1) { client.BaseAddress = new Uri(creditcardServiceBaseAddress_2 + "1"); LoggingFunction("Retry logic: Start with Alternative 1", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 1 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } else { client.BaseAddress = new Uri(creditcardServiceBaseAddress_3); LoggingFunction("Retry logic: Start with Alternative 2", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 2 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } });
old usages: AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
old usages: var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < StorageException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
old usages: var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
old usages: var trainRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var addFaceRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var findRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var addRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var matchRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
old usages: var exceptionPolicy = Policy.Handle < HttpRequestException >().Or < WebException >().Or < InvalidOperationException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains((int) r.StatusCode)).OrResult(r => r.IsSuccessStatusCode == false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
old usages: var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var connectPolicy = Policy.HandleResult < bool >(false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { Console.WriteLine($"Received {exception.GetType()}{exception.Message}"); Console.WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
old usages: var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
old usages: var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(ex, timeSpan) => { Console.WriteLine($"Exception: {ex.Message}"); Console.WriteLine($"Retrying in {timeSpan.Seconds} seconds"); });
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
old usages: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}下载异常，开始下载重试！\r\n{1}", strFileName, exception.Message)); });
old usages: var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
old usages: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"下载[{downloadUrl}时，发生异常，正在进行重试下载]", Category.Warn, Priority.High); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: Polly.Retry.RetryPolicy < int > politicaWaitAndRetry = Polly.Policy.HandleResult < int >(i => true).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(7) },(e, t, i, c) => ReportPollyError(e, t, i, c));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
old usages: var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
old usages: var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
old usages: var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(exception, timeSpan, retryCount, context) => ManageRetryException(exception, timeSpan, retryCount, context));
old usages: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
old usages: var retryPolicy = Policy.Handle < Exception >(e => ! cancellationToken.IsCancellationRequested).WaitAndRetryAsync(policyMaxAttempts, attempt => TimeSpan.FromSeconds(retrySeconds),(exception, timeSpan, attempt, context) => { if(attempt == 1) { _log.WriteWarningAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl}. Retry in {retrySeconds} sec.", exception.Message).GetAwaiter().GetResult(); } if(attempt % policyMaxAttempts == 0) { _log.WriteErrorAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl} after {policyMaxAttempts} attempts", exception).GetAwaiter().GetResult(); } });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var retryPolicy = Policy.Handle < ApiConnectionException >().WaitAndRetryAsync(DecorrelatedJitter(50, TimeSpan.FromMilliseconds(250), TimeSpan.FromSeconds(5)), onRetry :(exception, span, count, context) => { Console.WriteLine($"Action failed with error of \"{exception.Message}\". Waiting {span.TotalMilliseconds}ms to retry (#{count})"); });
old usages: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: IAsyncPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry :(exception, retryTimespan) => Log.Logger.Error(exception, $"Retry count {retryTimespan}"));
old usages: var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(2, retryCount => TimeSpan.FromSeconds(2),(exception, timeSpan, retryCount, context) => { _logger.LogWarning($"Call to {url} failed - Retry {retryCount} : TimeSpan {timeSpan} : Ex {exception.Message}"); });
old usages: var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: Polly.Retry.RetryPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3,(retry) => TimeSpan.FromSeconds(2),(ex, ts, attempt, context) => { logger.LogWarning($"An error occurred in attempt number {attempt} to release message {message.MessageId}" + $" in subscription \"{subscription}\": {ex.GetType().Name + " - " + ex.Message}"); });
old usages: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
old usages: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
old usages: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
old usages: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
old usages: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
============= Cluster end ==============

Log: generalized output is: var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context);
Interesting new usage: var arr = new IAsyncPolicy[] { Policy.Handle < HttpRequestException >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount} implemented with Polly's RetryPolicy " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); }), Policy.Handle < HttpRequestException >().CircuitBreakerAsync(_exceptionCountAllowedBeforeBreaking, TimeSpan.FromMinutes(1),(exception, duration) => { _logger.LogTrace("Circuit breaker opened"); },() => { _logger.LogTrace("Circuit breaker reset"); }) };
Log: Subsititution: Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):InvocationExpression -> new IAsyncPolicy[] { Policy.Handle < HttpRequestException >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount} implemented with Polly's RetryPolicy " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); }), Policy.Handle < HttpRequestException >().CircuitBreakerAsync(_exceptionCountAllowedBeforeBreaking, TimeSpan.FromMinutes(1),(exception, duration) => { _logger.LogTrace("Circuit breaker opened"); },() => { _logger.LogTrace("Circuit breaker reset"); }) }:ArrayCreationExpression
Log: Subsititution: policy:IdentifierToken -> arr:IdentifierToken
Correponding input: Policy arr = new IAsyncPolicy[] { Policy.Handle < HttpRequestException >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount} implemented with Polly's RetryPolicy " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); }), Policy.Handle < HttpRequestException >().CircuitBreakerAsync(_exceptionCountAllowedBeforeBreaking, TimeSpan.FromMinutes(1),(exception, duration) => { _logger.LogTrace("Circuit breaker opened"); },() => { _logger.LogTrace("Circuit breaker reset"); }) };
Interesting new usage: var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retry:IdentifierToken
Correponding input: Policy retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { });
Interesting new usage: var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryGetSubLanguagesPolicy:IdentifierToken
Correponding input: Policy retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Interesting new usage: var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retrySearchSubtitlesFromImdbPolicy:IdentifierToken
Correponding input: Policy retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Interesting new usage: var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryDownloadSubtitleToPathPolicy:IdentifierToken
Correponding input: Policy retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Interesting new usage: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SqlException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Interesting new usage: var waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SqlException >(x => x.Number == 596):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicyForError596:IdentifierToken
Correponding input: Policy waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SqlException >(x => x.Number == 1205):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 983 || x.Number == 978).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { _logger.LogInformation(exception, "Open Connection - DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { _logger.LogInformation(exception, "Open Connection - DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SqlException >(x => x.Number == 983 || x.Number == 978):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == 983 || x.Number == 978).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { _logger.LogInformation(exception, "Open Connection - DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Interesting new usage: var policy = Policy.HandleResult < LockLeaseResult >(lockLeaseResult => ! lockLeaseResult.Ok).WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(retryAfter));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount, retryAttempt => TimeSpan.FromSeconds(retryAfter)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < LockLeaseResult >(lockLeaseResult => ! lockLeaseResult.Ok):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.HandleResult < LockLeaseResult >(lockLeaseResult => ! lockLeaseResult.Ok).WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(retryAfter));
Interesting new usage: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { });
Interesting new usage: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(NumberOfRetries, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { _logger.LogError($"Could not replicate - exception {exception.Message}"); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (NumberOfRetries, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { _logger.LogError($"Could not replicate - exception {exception.Message}"); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(NumberOfRetries, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { _logger.LogError($"Could not replicate - exception {exception.Message}"); });
Interesting new usage: var falseResultPolicy = Policy.HandleResult(false).WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry());
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry()):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult(false):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> falseResultPolicy:IdentifierToken
Correponding input: Policy falseResultPolicy = Policy.HandleResult(false).WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(result, _) => OnRetry());
Interesting new usage: var exceptionPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> exceptionPolicy:IdentifierToken
Correponding input: Policy exceptionPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Interesting new usage: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount, _ => TimeSpan.FromSeconds(ReconnectIntervalSec),(exc, _) => OnRetry(exc));
Interesting new usage: var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode ==(HttpStatusCode) 429).WaitAndRetryAsync(retryCount : MaxRetries, sleepDurationProvider :(retryCount, response, context) => { return response.Result ?.Headers.RetryAfter.Delta.Value ?? TimeSpan.FromSeconds(30 * retryCount); }, onRetryAsync : async(response, timespan, retryCount, context) => { await Console.Out.WriteLineAsync($"{Environment.NewLine}Waiting {timespan} before retrying (attemp #{retryCount}/{MaxRetries})..."); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount : MaxRetries, sleepDurationProvider :(retryCount, response, context) => { return response.Result ?.Headers.RetryAfter.Delta.Value ?? TimeSpan.FromSeconds(30 * retryCount); }, onRetryAsync : async(response, timespan, retryCount, context) => { await Console.Out.WriteLineAsync($"{Environment.NewLine}Waiting {timespan} before retrying (attemp #{retryCount}/{MaxRetries})..."); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode ==(HttpStatusCode) 429):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode ==(HttpStatusCode) 429).WaitAndRetryAsync(retryCount : MaxRetries, sleepDurationProvider :(retryCount, response, context) => { return response.Result ?.Headers.RetryAfter.Delta.Value ?? TimeSpan.FromSeconds(30 * retryCount); }, onRetryAsync : async(response, timespan, retryCount, context) => { await Console.Out.WriteLineAsync($"{Environment.NewLine}Waiting {timespan} before retrying (attemp #{retryCount}/{MaxRetries})..."); });
Interesting new usage: var retryPolicy = Policy.Handle < AdalServiceException >().WaitAndRetryAsync(MAX_TOKEN_RETRY_ATTEMPTS, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (MAX_TOKEN_RETRY_ATTEMPTS, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < AdalServiceException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < AdalServiceException >().WaitAndRetryAsync(MAX_TOKEN_RETRY_ATTEMPTS, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Interesting new usage: var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.NotFound).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.NotFound):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryWithJitterPolicy:IdentifierToken
Correponding input: Policy retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.NotFound).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
Interesting new usage: AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose()):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Log: Subsititution: var:IdentifierName -> AsyncRetryPolicy < HttpResponseMessage >:GenericName
Log: Subsititution: Policy:IdentifierToken -> Policy < HttpResponseMessage >:GenericName
Correponding input: Policy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Interesting new usage: var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxRetryAttempts, i => pauseBetweenFailures):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < ArgumentException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryAndExitPolicy:IdentifierToken
Correponding input: Policy retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Interesting new usage: var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxRetryAttempts, i => pauseBetweenFailures):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < ArgumentException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Interesting new usage: var policy = Policy.Handle < Exception >(e => { Console.WriteLine("Tentando obter Token"); return true; }).WaitAndRetryAsync(3, i => TimeSpan.FromTicks(5));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, i => TimeSpan.FromTicks(5)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >(e => { Console.WriteLine("Tentando obter Token"); return true; }):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < Exception >(e => { Console.WriteLine("Tentando obter Token"); return true; }).WaitAndRetryAsync(3, i => TimeSpan.FromTicks(5));
Interesting new usage: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SqlException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < SqlException >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15), },(ext, timeSpan, retryCount, context) => { _logger.LogError(ext, $"Error - try retry (count: {retryCount}, timeSpan: {timeSpan})"); });
Interesting new usage: var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, _ => TimeSpan.FromSeconds(1)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
Interesting new usage: var policy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(x => x.StatusCode == HttpStatusCode.BadRequest).WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, _ => TimeSpan.FromSeconds(1)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError().OrResult(x => x.StatusCode == HttpStatusCode.BadRequest):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(x => x.StatusCode == HttpStatusCode.BadRequest).WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < SoapException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => Logger.Error(exception, "Служба СМС вернула ошибку. Код: {code}. Сообщение: {message}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", exception.HResult, exception.Message, timeSpan, retryCount));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => Logger.Error(exception, "Служба СМС вернула ошибку. Код: {code}. Сообщение: {message}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", exception.HResult, exception.Message, timeSpan, retryCount)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SoapException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.Handle < SoapException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => Logger.Error(exception, "Служба СМС вернула ошибку. Код: {code}. Сообщение: {message}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", exception.HResult, exception.Message, timeSpan, retryCount));
Interesting new usage: var waitAndRetryPolicy = Policy.HandleResult < DeliveryStatus >(status => status != DeliveryStatus.Delivered).WaitAndRetryAsync(11, retryAttempt => TimeSpan.FromSeconds(10 * retryAttempt),(result, timeSpan, retryCount, context) => Logger.Info("Сообщение {messageId} для заявки {appId} клиента {userName} не доставлено. Текущий статус отправки {status}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", messageId, applicationId, userName ?? "",((SmsDeliveryStatus) result.Result).GetDescription(), timeSpan, retryCount));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (11, retryAttempt => TimeSpan.FromSeconds(10 * retryAttempt),(result, timeSpan, retryCount, context) => Logger.Info("Сообщение {messageId} для заявки {appId} клиента {userName} не доставлено. Текущий статус отправки {status}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", messageId, applicationId, userName ?? "",((SmsDeliveryStatus) result.Result).GetDescription(), timeSpan, retryCount)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < DeliveryStatus >(status => status != DeliveryStatus.Delivered):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.HandleResult < DeliveryStatus >(status => status != DeliveryStatus.Delivered).WaitAndRetryAsync(11, retryAttempt => TimeSpan.FromSeconds(10 * retryAttempt),(result, timeSpan, retryCount, context) => Logger.Info("Сообщение {messageId} для заявки {appId} клиента {userName} не доставлено. Текущий статус отправки {status}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount}", messageId, applicationId, userName ?? "",((SmsDeliveryStatus) result.Result).GetDescription(), timeSpan, retryCount));
Interesting new usage: var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(result, timeSpan, retryCount, context) => Logger.Error(result.Exception, "Запрос к сервису статистики неудачен. Код: {statusCode}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount} {request}", result.Result.StatusCode, timeSpan, retryCount, requestContent));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(result, timeSpan, retryCount, context) => Logger.Error(result.Exception, "Запрос к сервису статистики неудачен. Код: {statusCode}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount} {request}", result.Result.StatusCode, timeSpan, retryCount, requestContent)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(result, timeSpan, retryCount, context) => Logger.Error(result.Exception, "Запрос к сервису статистики неудачен. Код: {statusCode}. Время ожидания до следующей попытки: {timeSpan}. Попытка: {retryCount} {request}", result.Result.StatusCode, timeSpan, retryCount, requestContent));
Interesting new usage: var waitAndRetryPolicy = Policy.HandleResult < ClientValidationRequest >(result => result ?.Result ==(int) ClientValidationResult.Requested).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < ClientValidationRequest >(result => result ?.Result ==(int) ClientValidationResult.Requested):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.HandleResult < ClientValidationRequest >(result => result ?.Result ==(int) ClientValidationResult.Requested).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Interesting new usage: var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < bool >(result => result == false).WaitAndRetryAsync(RetryCount, i => TimeSpan.FromSeconds(WaitSecondsBeforeRetry));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (RetryCount, i => TimeSpan.FromSeconds(WaitSecondsBeforeRetry)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().OrResult < bool >(result => result == false):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < HttpRequestException >().OrResult < bool >(result => result == false).WaitAndRetryAsync(RetryCount, i => TimeSpan.FromSeconds(WaitSecondsBeforeRetry));
Interesting new usage: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retriesCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan) => { logger.LogError(exception, $"Operation failed, retrying in {timeSpan.Seconds} seconds"); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retriesCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan) => { logger.LogError(exception, $"Operation failed, retrying in {timeSpan.Seconds} seconds"); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(retriesCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan) => { logger.LogError(exception, $"Operation failed, retrying in {timeSpan.Seconds} seconds"); });
Interesting new usage: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxNumberOfAttempts, p => TimeSpan.FromSeconds(p)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Interesting new usage: var retryFailedUserPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxNumberOfAttempts, p => TimeSpan.FromSeconds(p)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryFailedUserPolicy:IdentifierToken
Correponding input: Policy retryFailedUserPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxNumberOfAttempts, p => TimeSpan.FromSeconds(p));
Interesting new usage: var policy = Policy.Handle < ResponseException >().Or < ConnectionPoolBusyException >().Or < ServerUnavailableException >().WaitAndRetryAsync(retryCount : 10, sleepDurationProvider :(attempt, exception, context) => { if(exception is ResponseException responseException && responseException.CosmosDbStatusCode() == RetryAfterStatusCode) { return TimeSpan.FromSeconds(5 + 5 * attempt * _jitterer.NextDouble()); } _logger.LogInformation($"Exception {exception.GetType()}. Retry immediately"); return TimeSpan.Zero; }, onRetryAsync :(exception, waitTime, attempt, _) => { totalWaitTime = totalWaitTime.Add(waitTime); retryCount = attempt; if(exception is ResponseException responseException) { var exceptionRu = CosmosResponse.ParseRequestCharge(responseException.StatusAttributes); totalRu += exceptionRu; _logger.LogInformation($"ResponseException cost {exceptionRu}RU"); } if(exception is ConnectionPoolBusyException || exception is ServerUnavailableException) { _logger.LogInformation($"Resetting the GremlinClient after experiencing an '{exception.GetType()}'"); _factory.ClearGraphClient(); } return Task.CompletedTask; });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount : 10, sleepDurationProvider :(attempt, exception, context) => { if(exception is ResponseException responseException && responseException.CosmosDbStatusCode() == RetryAfterStatusCode) { return TimeSpan.FromSeconds(5 + 5 * attempt * _jitterer.NextDouble()); } _logger.LogInformation($"Exception {exception.GetType()}. Retry immediately"); return TimeSpan.Zero; }, onRetryAsync :(exception, waitTime, attempt, _) => { totalWaitTime = totalWaitTime.Add(waitTime); retryCount = attempt; if(exception is ResponseException responseException) { var exceptionRu = CosmosResponse.ParseRequestCharge(responseException.StatusAttributes); totalRu += exceptionRu; _logger.LogInformation($"ResponseException cost {exceptionRu}RU"); } if(exception is ConnectionPoolBusyException || exception is ServerUnavailableException) { _logger.LogInformation($"Resetting the GremlinClient after experiencing an '{exception.GetType()}'"); _factory.ClearGraphClient(); } return Task.CompletedTask; }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < ResponseException >().Or < ConnectionPoolBusyException >().Or < ServerUnavailableException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < ResponseException >().Or < ConnectionPoolBusyException >().Or < ServerUnavailableException >().WaitAndRetryAsync(retryCount : 10, sleepDurationProvider :(attempt, exception, context) => { if(exception is ResponseException responseException && responseException.CosmosDbStatusCode() == RetryAfterStatusCode) { return TimeSpan.FromSeconds(5 + 5 * attempt * _jitterer.NextDouble()); } _logger.LogInformation($"Exception {exception.GetType()}. Retry immediately"); return TimeSpan.Zero; }, onRetryAsync :(exception, waitTime, attempt, _) => { totalWaitTime = totalWaitTime.Add(waitTime); retryCount = attempt; if(exception is ResponseException responseException) { var exceptionRu = CosmosResponse.ParseRequestCharge(responseException.StatusAttributes); totalRu += exceptionRu; _logger.LogInformation($"ResponseException cost {exceptionRu}RU"); } if(exception is ConnectionPoolBusyException || exception is ServerUnavailableException) { _logger.LogInformation($"Resetting the GremlinClient after experiencing an '{exception.GetType()}'"); _factory.ClearGraphClient(); } return Task.CompletedTask; });
Interesting new usage: var policyRegistry = new PolicyRegistry { { RetryPolicyKey.NoRetry.ToString(), Policy.NoOpAsync() }, { RetryPolicyKey.BasicRetryOnRpc.ToString(), Policy.Handle < RpcException >().RetryAsync(MaxRetries,(exception, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithExponentialBackoff.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(Backoff.ExponentialBackoff(TimeSpan.FromSeconds(1), MaxRetries),(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithJitter.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(MaxRetries, retryAttempt => { var backoffSpans = Backoff.DecorrelatedJitterBackoffV2(TimeSpan.FromSeconds(1), MaxRetries).ToList(); return backoffSpans[retryAttempt - 1]; },(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { CachePolicyKey.InMemoryCache.ToString(), Policy.CacheAsync(componentContext.Resolve < IAsyncCacheProvider >(), TimeSpan.FromMinutes(5),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache miss {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put {cacheKey}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get error {cacheKey}; {exception}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put error {cacheKey}; {exception}")) }, { CachePolicyKey.NoCache.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.NoTimeout.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.DefaultPessimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Pessimistic,(context, span, task) => { task.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); console.Out.WriteLine($"Operation {context.OperationKey} timed out."); return Task.CompletedTask; }) }, { TimeoutPolicyKey.DefaultOptimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Optimistic,(context, span, abandonedTask) => { console.Out.WriteLine($"Operation: {context.OperationKey}, timeout after {span}. "); abandonedTask.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); return Task.CompletedTask; }) }, { CircuitBreakerPolicyKey.NoBreaker.ToString(), Policy.NoOpAsync() }, { CircuitBreakerPolicyKey.DefaultCircuitBreaker.ToString(), Policy.Handle < RpcException >().CircuitBreakerAsync(2, TimeSpan.FromSeconds(2),(exception, span) => { console.WriteLine($"Circuit broken. Span: {span}; Exception: {exception.Message};"); },() => { console.WriteLine("Circuit reset."); },() => { console.WriteLine("Circuit half openBa."); }) }, };
Log: Subsititution: Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):InvocationExpression -> new PolicyRegistry { { RetryPolicyKey.NoRetry.ToString(), Policy.NoOpAsync() }, { RetryPolicyKey.BasicRetryOnRpc.ToString(), Policy.Handle < RpcException >().RetryAsync(MaxRetries,(exception, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithExponentialBackoff.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(Backoff.ExponentialBackoff(TimeSpan.FromSeconds(1), MaxRetries),(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithJitter.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(MaxRetries, retryAttempt => { var backoffSpans = Backoff.DecorrelatedJitterBackoffV2(TimeSpan.FromSeconds(1), MaxRetries).ToList(); return backoffSpans[retryAttempt - 1]; },(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { CachePolicyKey.InMemoryCache.ToString(), Policy.CacheAsync(componentContext.Resolve < IAsyncCacheProvider >(), TimeSpan.FromMinutes(5),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache miss {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put {cacheKey}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get error {cacheKey}; {exception}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put error {cacheKey}; {exception}")) }, { CachePolicyKey.NoCache.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.NoTimeout.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.DefaultPessimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Pessimistic,(context, span, task) => { task.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); console.Out.WriteLine($"Operation {context.OperationKey} timed out."); return Task.CompletedTask; }) }, { TimeoutPolicyKey.DefaultOptimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Optimistic,(context, span, abandonedTask) => { console.Out.WriteLine($"Operation: {context.OperationKey}, timeout after {span}. "); abandonedTask.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); return Task.CompletedTask; }) }, { CircuitBreakerPolicyKey.NoBreaker.ToString(), Policy.NoOpAsync() }, { CircuitBreakerPolicyKey.DefaultCircuitBreaker.ToString(), Policy.Handle < RpcException >().CircuitBreakerAsync(2, TimeSpan.FromSeconds(2),(exception, span) => { console.WriteLine($"Circuit broken. Span: {span}; Exception: {exception.Message};"); },() => { console.WriteLine("Circuit reset."); },() => { console.WriteLine("Circuit half openBa."); }) }, }:ObjectCreationExpression
Log: Subsititution: policy:IdentifierToken -> policyRegistry:IdentifierToken
Correponding input: Policy policyRegistry = new PolicyRegistry { { RetryPolicyKey.NoRetry.ToString(), Policy.NoOpAsync() }, { RetryPolicyKey.BasicRetryOnRpc.ToString(), Policy.Handle < RpcException >().RetryAsync(MaxRetries,(exception, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithExponentialBackoff.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(Backoff.ExponentialBackoff(TimeSpan.FromSeconds(1), MaxRetries),(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { RetryPolicyKey.RetryOnRpcWithJitter.ToString(), Policy.Handle < RpcException >().WaitAndRetryAsync(MaxRetries, retryAttempt => { var backoffSpans = Backoff.DecorrelatedJitterBackoffV2(TimeSpan.FromSeconds(1), MaxRetries).ToList(); return backoffSpans[retryAttempt - 1]; },(exception, timeSpan, retryAttempt, context) => { console.Out.WriteLine($"Operation: {context.OperationKey}; TimeSpan: {timeSpan.ToString()}. Attempt {retryAttempt - 1} failed: {exception.Message}. Retrying."); return Task.CompletedTask; }) }, { CachePolicyKey.InMemoryCache.ToString(), Policy.CacheAsync(componentContext.Resolve < IAsyncCacheProvider >(), TimeSpan.FromMinutes(5),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache miss {cacheKey}"),(policyContext, cacheKey) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put {cacheKey}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache get error {cacheKey}; {exception}"),(policyContext, cacheKey, exception) => console.WriteLine($"Operation {policyContext.OperationKey}: Cache put error {cacheKey}; {exception}")) }, { CachePolicyKey.NoCache.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.NoTimeout.ToString(), Policy.NoOpAsync() }, { TimeoutPolicyKey.DefaultPessimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Pessimistic,(context, span, task) => { task.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); console.Out.WriteLine($"Operation {context.OperationKey} timed out."); return Task.CompletedTask; }) }, { TimeoutPolicyKey.DefaultOptimisticTimeout.ToString(), Policy.TimeoutAsync(TimeSpan.FromMilliseconds(500), TimeoutStrategy.Optimistic,(context, span, abandonedTask) => { console.Out.WriteLine($"Operation: {context.OperationKey}, timeout after {span}. "); abandonedTask.ContinueWith(t => { if(t.IsFaulted) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, eventually terminated with: {t.Exception.Message}."); } else if(t.IsCanceled) { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task cancelled."); } else { console.Out.WriteLine($"Operation {context.OperationKey}: execution timed out after {span.TotalSeconds} seconds, task completed."); } }); return Task.CompletedTask; }) }, { CircuitBreakerPolicyKey.NoBreaker.ToString(), Policy.NoOpAsync() }, { CircuitBreakerPolicyKey.DefaultCircuitBreaker.ToString(), Policy.Handle < RpcException >().CircuitBreakerAsync(2, TimeSpan.FromSeconds(2),(exception, span) => { console.WriteLine($"Circuit broken. Span: {span}; Exception: {exception.Message};"); },() => { console.WriteLine("Circuit reset."); },() => { console.WriteLine("Circuit half openBa."); }) }, };
Interesting new usage: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (_retries, i => TimeSpan.FromSeconds(_retryInterval)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Interesting new usage: var retryPolice = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => TimeSpan.FromSeconds(retryAttempt)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolice:IdentifierToken
Correponding input: Policy retryPolice = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Interesting new usage: var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxtrys, x => seconds);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxtrys, x => seconds):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolity:IdentifierToken
Correponding input: Policy retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxtrys, x => seconds);
Interesting new usage: var retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.GatewayTimeout || msg.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.GatewayTimeout || msg.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryWithJitterPolicy:IdentifierToken
Correponding input: Policy retryWithJitterPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.GatewayTimeout || msg.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(jitterer.Next(0, 100)));
Interesting new usage: var policy = Policy.Handle < HttpRequestException >().Or < OperationCanceledException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(delayAfterFailure));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount, i => TimeSpan.FromSeconds(delayAfterFailure)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().Or < OperationCanceledException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < HttpRequestException >().Or < OperationCanceledException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(delayAfterFailure));
Interesting new usage: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(10));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, _ => TimeSpan.FromSeconds(10)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(10));
Interesting new usage: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(policyConfigs.RetryCount, _ => TimeSpan.FromMilliseconds(policyConfigs.RetryDelayInMs));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (policyConfigs.RetryCount, _ => TimeSpan.FromMilliseconds(policyConfigs.RetryDelayInMs)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(policyConfigs.RetryCount, _ => TimeSpan.FromMilliseconds(policyConfigs.RetryDelayInMs));
Interesting new usage: var httpRetryPolicy = Policy.Handle < HttpRequestException >().Or < TaskCanceledException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(RetryRequired).WaitAndRetryAsync(GetBackOff(maxRetries));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (GetBackOff(maxRetries)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().Or < TaskCanceledException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(RetryRequired):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> httpRetryPolicy:IdentifierToken
Correponding input: Policy httpRetryPolicy = Policy.Handle < HttpRequestException >().Or < TaskCanceledException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(RetryRequired).WaitAndRetryAsync(GetBackOff(maxRetries));
Interesting new usage: var retryAfterPolicy = Policy.HandleResult < HttpResponseMessage >(ContainsRetryAfterHeader).WaitAndRetryAsync(maxRetries, sleepDurationProvider,(outcome, timespan, retryCount, context) => Task.CompletedTask);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxRetries, sleepDurationProvider,(outcome, timespan, retryCount, context) => Task.CompletedTask):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < HttpResponseMessage >(ContainsRetryAfterHeader):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryAfterPolicy:IdentifierToken
Correponding input: Policy retryAfterPolicy = Policy.HandleResult < HttpResponseMessage >(ContainsRetryAfterHeader).WaitAndRetryAsync(maxRetries, sleepDurationProvider,(outcome, timespan, retryCount, context) => Task.CompletedTask);
Interesting new usage: var retryPolicy = HandleResult().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount, retryAttempt => retryDelay);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount, retryAttempt => retryDelay):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HandleResult().Or < TimeoutRejectedException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = HandleResult().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount, retryAttempt => retryDelay);
Interesting new usage: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Console.WriteLine($"{exception.Message} : Auto delay for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Interesting new usage: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
Interesting new usage: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(500),(exception, calculationWithDuration) => { Console.WriteLine($"Retrying after 200ms: {exception.Message} : {calculationWithDuration}"); });
Interesting new usage: AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask; });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask; }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryAndSleepPolicy:IdentifierToken
Log: Subsititution: var:IdentifierName -> AsyncRetryPolicy < HttpResponseMessage >:GenericName
Log: Subsititution: Policy:IdentifierToken -> Policy < HttpResponseMessage >:GenericName
Correponding input: Policy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask; });
Interesting new usage: var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask; });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask; }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < Response >(response => ! this.condition(response)):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryAndSleepPolicy:IdentifierToken
Correponding input: Policy retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask; });
Interesting new usage: var retry = Policy.Handle < Exception >().WaitAndRetryAsync(Backoff.LinearBackoff(TimeSpan.FromSeconds(settings.RetryInitialDelaySeconds), settings.RetryCount),(exception, span, retryCount, context) => { logger.LogError(exception, "{@EventType} {@Realm} {@TimeSpan} {@retryCount}", "Retry", description, span, retryCount); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (Backoff.LinearBackoff(TimeSpan.FromSeconds(settings.RetryInitialDelaySeconds), settings.RetryCount),(exception, span, retryCount, context) => { logger.LogError(exception, "{@EventType} {@Realm} {@TimeSpan} {@retryCount}", "Retry", description, span, retryCount); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retry:IdentifierToken
Correponding input: Policy retry = Policy.Handle < Exception >().WaitAndRetryAsync(Backoff.LinearBackoff(TimeSpan.FromSeconds(settings.RetryInitialDelaySeconds), settings.RetryCount),(exception, span, retryCount, context) => { logger.LogError(exception, "{@EventType} {@Realm} {@TimeSpan} {@retryCount}", "Retry", description, span, retryCount); });
Interesting new usage: var policy = Policy.Handle < Exception >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(exception, timeSpan, retryCount, context) => { });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(exception, timeSpan, retryCount, context) => { }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(3) },(exception, timeSpan, retryCount, context) => { });
Interesting new usage: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SqlException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Interesting new usage: IAsyncPolicy < HttpResponseMessage > policy = Policy.Handle < SocketException >().OrTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SocketException >().OrTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Log: Subsititution: var:IdentifierName -> IAsyncPolicy < HttpResponseMessage >:GenericName
Log: Subsititution: Policy:IdentifierToken -> IAsyncPolicy < HttpResponseMessage >:GenericName
Correponding input: IAsyncPolicy < HttpResponseMessage > policy = Policy.Handle < SocketException >().OrTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Interesting new usage: var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (1, retryAttempt => TimeSpan.FromSeconds(10)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryWhenServiceUnavailable:IdentifierToken
Correponding input: Policy retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Interesting new usage: var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromSeconds(5)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryWhenTimeout:IdentifierToken
Correponding input: Policy retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Interesting new usage: var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryWhenThrottling:IdentifierToken
Correponding input: Policy retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Interesting new usage: var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxRetryAttempts, i => pauseBetweenFailures):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Interesting new usage: var retry = Policy < HttpResponseMessage >.Handle < Exception >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, i => TimeSpan.FromSeconds(1)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy < HttpResponseMessage >.Handle < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retry:IdentifierToken
Correponding input: Policy retry = Policy < HttpResponseMessage >.Handle < Exception >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
Interesting new usage: var policy = Policy.Handle < InvalidOperationException >().Or < Exception >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < InvalidOperationException >().Or < Exception >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < InvalidOperationException >().Or < Exception >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(1),(ex, time) => { _logger.LogWarning(ex.ToString()); });
Interesting new usage: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, i => TimeSpan.FromSeconds(1)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SqlException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(1));
Interesting new usage: AsyncRetryPolicy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask.ConfigureAwait(false); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask.ConfigureAwait(false); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryAndSleepPolicy:IdentifierToken
Log: Subsititution: var:IdentifierName -> AsyncRetryPolicy < HttpResponseMessage >:GenericName
Log: Subsititution: Policy:IdentifierToken -> Policy < HttpResponseMessage >:GenericName
Correponding input: Policy < HttpResponseMessage > retryAndSleepPolicy = Policy.HandleResult < HttpResponseMessage >(r => ShoulRetryOnHttpResponse(r)).WaitAndRetryAsync(retryCount : retryConfiguration.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(retryConfiguration.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryAttempt, context) => { logger.Info($"Retry Attempt: {retryAttempt}"); await Task.CompletedTask.ConfigureAwait(false); });
Interesting new usage: var retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask.ConfigureAwait(false); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask.ConfigureAwait(false); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < Response >(response => ! this.condition(response)):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryAndSleepPolicy:IdentifierToken
Correponding input: Policy retryAndSleepPolicy = Policy.HandleResult < Response >(response => ! this.condition(response)).WaitAndRetryAsync(retryCount : waiterConfig.MaxAttempts, sleepDurationProvider :(retryCount, response, context) => TimeSpan.FromSeconds(waiterConfig.GetNextDelayInSeconds(retryCount)), onRetryAsync : async(response, timespan, retryCount, context) => { logger.Trace($"Retry Attempt: {retryCount}"); await Task.CompletedTask.ConfigureAwait(false); });
Interesting new usage: var policyRetry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(3, retryTimespan => TimeSpan.FromSeconds(Math.Pow(2, retryTimespan)),(exception, timespan, retryCount, context) => { var msg = $"第 {retryCount} 次进行错误重试 " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryTimespan => TimeSpan.FromSeconds(Math.Pow(2, retryTimespan)),(exception, timespan, retryCount, context) => { var msg = $"第 {retryCount} 次进行错误重试 " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < InvalidOperationException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policyRetry:IdentifierToken
Correponding input: Policy policyRetry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(3, retryTimespan => TimeSpan.FromSeconds(Math.Pow(2, retryTimespan)),(exception, timespan, retryCount, context) => { var msg = $"第 {retryCount} 次进行错误重试 " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); });
Interesting new usage: var waitAndRetryPolicy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(e => HttpStatusCodeWorthRetry.ToList().Contains((int) e.StatusCode)).WaitAndRetryAsync(MaxRetryCount, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => PolicyLog($"API is throttling our requests automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (MaxRetryCount, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => PolicyLog($"API is throttling our requests automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms")):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >().OrResult < HttpResponseMessage >(e => HttpStatusCodeWorthRetry.ToList().Contains((int) e.StatusCode)):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> waitAndRetryPolicy:IdentifierToken
Correponding input: Policy waitAndRetryPolicy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(e => HttpStatusCodeWorthRetry.ToList().Contains((int) e.StatusCode)).WaitAndRetryAsync(MaxRetryCount, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => PolicyLog($"API is throttling our requests automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"));
Interesting new usage: var policy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < Exception >().OrResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(1000));
Interesting new usage: AsyncRetryPolicy retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Log: Subsititution: var:IdentifierToken -> AsyncRetryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Interesting new usage: var polly = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, pause => TimeSpan.FromSeconds(5));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, pause => TimeSpan.FromSeconds(5)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> polly:IdentifierToken
Correponding input: Policy polly = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, pause => TimeSpan.FromSeconds(5));
Interesting new usage: var policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(_appSettings.RetryAttempt, retryAttempt => TimeSpan.FromMilliseconds(3000));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (_appSettings.RetryAttempt, retryAttempt => TimeSpan.FromMilliseconds(3000)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode != HttpStatusCode.OK):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(_appSettings.RetryAttempt, retryAttempt => TimeSpan.FromMilliseconds(3000));
Interesting new usage: var retryPolicy = Policy.HandleResult < IRestResponse >(x => FindWarning(x) is null && x.StatusCode != HttpStatusCode.NotFound && x.StatusCode != HttpStatusCode.Unauthorized && x.StatusCode != HttpStatusCode.Conflict && x.StatusCode != HttpStatusCode.BadRequest && x.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(retryNumber, retryAttempt => TimeSpan.FromSeconds(retrySleepSeconds));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryNumber, retryAttempt => TimeSpan.FromSeconds(retrySleepSeconds)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < IRestResponse >(x => FindWarning(x) is null && x.StatusCode != HttpStatusCode.NotFound && x.StatusCode != HttpStatusCode.Unauthorized && x.StatusCode != HttpStatusCode.Conflict && x.StatusCode != HttpStatusCode.BadRequest && x.StatusCode != HttpStatusCode.OK):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.HandleResult < IRestResponse >(x => FindWarning(x) is null && x.StatusCode != HttpStatusCode.NotFound && x.StatusCode != HttpStatusCode.Unauthorized && x.StatusCode != HttpStatusCode.Conflict && x.StatusCode != HttpStatusCode.BadRequest && x.StatusCode != HttpStatusCode.OK).WaitAndRetryAsync(retryNumber, retryAttempt => TimeSpan.FromSeconds(retrySleepSeconds));
Interesting new usage: var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Trying for the {retryCount} time!"); Console.ForegroundColor = ConsoleColor.White; });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Trying for the {retryCount} time!"); Console.ForegroundColor = ConsoleColor.White; }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retry:IdentifierToken
Correponding input: Policy retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Trying for the {retryCount} time!"); Console.ForegroundColor = ConsoleColor.White; });
Interesting new usage: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, x => TimeSpan.FromSeconds(1),(result, span) => { }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
Interesting new usage: var policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, x => TimeSpan.FromSeconds(1),(result, span) => { }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(1),(result, span) => { });
Interesting new usage: var retryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(1),(result, span, retryCount, ctx) => { Console.WriteLine($"Retrying({retryCount})..."); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => TimeSpan.FromSeconds(1),(result, span, retryCount, ctx) => { Console.WriteLine($"Retrying({retryCount})..."); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(1),(result, span, retryCount, ctx) => { Console.WriteLine($"Retrying({retryCount})..."); });
Interesting new usage: var retryPolicy = Policy.Handle < HttpRequestException >().Or < Exception >().OrResult < HttpResponseMessage >(res => { return res.StatusCode != System.Net.HttpStatusCode.OK; }).WaitAndRetryAsync(sleepDurations : new[] { TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(200), TimeSpan.FromMilliseconds(300) }, onRetry :(exception, ts, context) => { Console.WriteLine($"polly.retry：exMsg={exception.Exception ?.Message}, {ts.Minutes * 60 + ts.Seconds}"); });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (sleepDurations : new[] { TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(200), TimeSpan.FromMilliseconds(300) }, onRetry :(exception, ts, context) => { Console.WriteLine($"polly.retry：exMsg={exception.Exception ?.Message}, {ts.Minutes * 60 + ts.Seconds}"); }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().Or < Exception >().OrResult < HttpResponseMessage >(res => { return res.StatusCode != System.Net.HttpStatusCode.OK; }):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < HttpRequestException >().Or < Exception >().OrResult < HttpResponseMessage >(res => { return res.StatusCode != System.Net.HttpStatusCode.OK; }).WaitAndRetryAsync(sleepDurations : new[] { TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(200), TimeSpan.FromMilliseconds(300) }, onRetry :(exception, ts, context) => { Console.WriteLine($"polly.retry：exMsg={exception.Exception ?.Message}, {ts.Minutes * 60 + ts.Seconds}"); });
Interesting new usage: var retryWaitPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryWaitPolicy:IdentifierToken
Correponding input: Policy retryWaitPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Interesting new usage: var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Interesting new usage: var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; }):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Interesting new usage: var retryPolicy = Policy.Handle < Exception >((ex) => { logger.Log(LogSeverity.Error,(ex.InnerException != null) ? ex.InnerException.Message : ex.Message + "\r\n GetTrendingStocks retry FAILURE"); return !(ex is Polly.CircuitBreaker.BrokenCircuitException); }).WaitAndRetryAsync(_retryCount, x => TimeSpan.FromMilliseconds(_sleepTimeAfterFail));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (_retryCount, x => TimeSpan.FromMilliseconds(_sleepTimeAfterFail)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < Exception >((ex) => { logger.Log(LogSeverity.Error,(ex.InnerException != null) ? ex.InnerException.Message : ex.Message + "\r\n GetTrendingStocks retry FAILURE"); return !(ex is Polly.CircuitBreaker.BrokenCircuitException); }):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < Exception >((ex) => { logger.Log(LogSeverity.Error,(ex.InnerException != null) ? ex.InnerException.Message : ex.Message + "\r\n GetTrendingStocks retry FAILURE"); return !(ex is Polly.CircuitBreaker.BrokenCircuitException); }).WaitAndRetryAsync(_retryCount, x => TimeSpan.FromMilliseconds(_sleepTimeAfterFail));
Interesting new usage: var retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (3, retryAttempt => TimeSpan.FromSeconds(retryAttempt)):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> HttpPolicyExtensions.HandleTransientHttpError():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Interesting new usage: var policy = Policy.Handle < SentNotificationException >().WaitAndRetryAsync(_maxRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(3, retryAttempt)));
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (_maxRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(3, retryAttempt))):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < SentNotificationException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> policy:IdentifierToken
Correponding input: Policy policy = Policy.Handle < SentNotificationException >().WaitAndRetryAsync(_maxRetryAttempts, retryAttempt => TimeSpan.FromSeconds(Math.Pow(3, retryAttempt)));
Interesting new usage: var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxRetryAttempts, i => pauseBetweenFailures):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Interesting new usage: var retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r =>(int) r.StatusCode == 429).WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxRetryAttempts, i => pauseBetweenFailures):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r =>(int) r.StatusCode == 429):InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r =>(int) r.StatusCode == 429).WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Interesting new usage: var retryPolicy = Policy.Handle < System.Net.Sockets.SocketException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: Subsititution: (new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => contextData = context):ArgumentList -> (maxRetryAttempts, i => pauseBetweenFailures):ArgumentList
Log: Subsititution: Policy.Handle < DivideByZeroException >():InvocationExpression -> Policy.Handle < System.Net.Sockets.SocketException >():InvocationExpression
Log: Subsititution: policy:IdentifierToken -> retryPolicy:IdentifierToken
Correponding input: Policy retryPolicy = Policy.Handle < System.Net.Sockets.SocketException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: Input to synthesize the program:
Log: Policy arr = new IAsyncPolicy[] { Policy.Handle < HttpRequestException >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount} implemented with Polly's RetryPolicy " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); }), Policy.Handle < HttpRequestException >().CircuitBreakerAsync(_exceptionCountAllowedBeforeBreaking, TimeSpan.FromMinutes(1),(exception, duration) => { _logger.LogTrace("Circuit breaker opened"); },() => { _logger.LogTrace("Circuit breaker reset"); }) };
Log: ---------------------
Log: var arr = new IAsyncPolicy[] { Policy.Handle < HttpRequestException >().WaitAndRetryAsync(_retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount} implemented with Polly's RetryPolicy " + $"of {context.PolicyKey}" + $"at {context.OperationKey}, " + $"due to: {exception}."; _logger.LogWarning(msg); _logger.LogDebug(msg); }), Policy.Handle < HttpRequestException >().CircuitBreakerAsync(_exceptionCountAllowedBeforeBreaking, TimeSpan.FromMinutes(1),(exception, duration) => { _logger.LogTrace("Circuit breaker opened"); },() => { _logger.LogTrace("Circuit breaker reset"); }) };
Log: Policy retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Log: ---------------------
Log: var retry = HttpPolicyExtensions.HandleTransientHttpError().WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), },(outcome, timespan, retryCount, context) => { Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine($"Tentando pela {retryCount} vez!"); Console.ForegroundColor = ConsoleColor.White; });
Log: Policy waitAndRetryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { });
Log: ---------------------
Log: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(50, retryAttempt => TimeSpan.FromSeconds(1),(exception, timeSpan, retryCount, context) => { });
Log: Policy retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: ---------------------
Log: var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Policy retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: ---------------------
Log: var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Policy retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: ---------------------
Log: var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: Policy policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: ---------------------
Log: var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(new Random(Guid.NewGuid().GetHashCode()).Next(0, 1000)));
Log: Policy waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: ---------------------
Log: var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: Policy waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: ---------------------
Log: var waitAndRetryPolicyForError596 = Policy.Handle < SqlException >(x => x.Number == 596).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5 + retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: Policy waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: ---------------------
Log: var waitAndRetryPolicy = Policy.Handle < SqlException >(x => x.Number == -2 || x.Number == 1205).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromMilliseconds(200 * retryAttempt), onRetry :(exception, calculatedWaitDuration, retryCount, context) => { var sql = context.ContainsKey("sql") ? context["sql"] : ""; using(_logger.BeginScope(new Dictionary < string, object > {["sql"] = sql })) _logger.LogInformation(exception, "DB Retry {RetryCount} occurred after {timeSpan}", retryCount, calculatedWaitDuration); });
Log: predict is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => capturedContext = context);
Log: output  is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds(), 2.Seconds(), 3.Seconds() },(_, __, context) => capturedContext = context);
Log: ----------------------------------------------------
Log: predict is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds() },(_, __, context) => contextValue = context["key"].ToString());
Log: output  is var policy = Policy.Handle < DivideByZeroException >().WaitAndRetryAsync(new[] { 1.Seconds() },(_, __, context) => contextValue = context["key"].ToString());
Log: ----------------------------------------------------
Log: old usage is var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: predict is null
Log: old usage is var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: predict is null
Log: old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogTrace($"Exception {exception.GetType().Name} with message ${exception.Message} detected on attempt {retry} of {retries}"); });
Log: predict is null
Log: old usage is var retry = Policy.Handle < DbException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnPolicyRetry);
Log: predict is null
Log: old usage is var retry = Policy.Handle < DbException >().Or < TimeoutException >().WaitAndRetryAsync(RetryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), OnRetry);
Log: predict is null
Log: old usage is var policy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, i => TimeSpan.FromMilliseconds(i * retryTimeoutRatioMs));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
Log: predict is null
Log: old usage is RetryPolicy < HttpResponseMessage > retryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(r => r.StatusCode == TooManyRequests).WaitAndRetryAsync(MaxAbsoluteLinkRetry, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < BoxException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream = new MemoryStream());
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServerException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < GoogleApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ServiceException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < ODException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < OneDriveException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => stream.Reset());
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < pCloudException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var retryPolicyWithAction = Policy.Handle < YandexApiException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, ts) => content.Seek(0, SeekOrigin.Begin));
Log: predict is null
Log: old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Edge Module, because of exception {exception}"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < TimeoutException >().Or < DeviceMessageLockLostException >().Or < IotHubCommunicationException >().Or < IotHubThrottledException >().Or < ServerBusyException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, span, retryCount, context) => { _logger.Warn(exception, $"Retry {retryCount}/{5} sending to IoT Hub, because of exception {exception}"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.StatusCode ==(System.Net.HttpStatusCode) 429) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}")).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.5 * Math.Pow(2, attempt)));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e =>(e.StatusCode == HttpStatusCode.ServiceUnavailable) ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Running\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"NotStarted\"}") ||(e.Content.ReadAsStringAsync().Result == "{\"status\":\"Failed\"}")).WaitAndRetryAsync(20, attempt => TimeSpan.FromSeconds(1 * Math.Pow(2, attempt)));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is var policy = RetryPolicy.Handle < Exception >().WaitAndRetryAsync(_pTimeSpans,(ex, time, context) => { _logger.Error("Subscribe/RetryPolicy", "EventBusRabbitMQ", $"message:{ea.Body}--count:{context.Count}--time:{time}", ex); });
Log: predict is null
Log: old usage is var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: predict is null
Log: old usage is var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : retry => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, ctx) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > HttpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(rsp => ValidRetry.Contains(rsp.StatusCode)).WaitAndRetryAsync(0, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 2));
Log: predict is null
Log: old usage is IAsyncPolicy AdoRetryPolicy = Policy.Handle < Exception >(ex => true).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt) / 4));
Log: predict is null
Log: old usage is var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var retryPolicy = Policy.HandleResult < JobStatusType >(r => r != JobStatusType.Waiting).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
Log: predict is null
Log: old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { _logger.Warn(ex.ToString()); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < BrokerUnreachableException >().Or < SocketException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(ex, time) => { });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var authorisation = Policy.HandleResult < ValidatedToken >(_ => ! _.Succeeded).WaitAndRetryAsync(retries, SleepDurationProvider, async(outcome, retryNumber, context) => await actionToRetryOnFailure);
Log: predict is null
Log: old usage is var policyRetry = Policy.HandleResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(retryCount, i => TimeSpan.FromSeconds(retryWaitsec),(resultPolly, timeSpan, countRetried, context) => { System.Console.WriteLine($"Request failed with {resultPolly.Result.StatusCode}"); });
Log: predict is null
Log: old usage is var retry = Policy.Handle < HttpRequestException >().Or < Polly.Timeout.TimeoutRejectedException >().OrResult < HttpResponseMessage >(response => { return retriable.Contains((int) response.StatusCode); }).WaitAndRetryAsync(retryCount : 5, sleepDurationProvider :(retryCount, response, context) => { var serverWait = response.Result ?.Headers.RetryAfter ?.Delta; var clientWait =(double) rand.Next(retryBaseDelay,(int) Math.Pow(2, retryCount) * retryMultiplier); var wait = clientWait; if(serverWait.HasValue) { wait = serverWait.Value.TotalMilliseconds + clientWait; } return TimeSpan.FromMilliseconds(wait); }, onRetryAsync :(response, sleepTime, retryCount, content) => Task.CompletedTask);
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(_retries, i => TimeSpan.FromSeconds(_retryInterval));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var executionPolicy = Policy.Handle < ProvisionedThroughputExceededException >().WaitAndRetryAsync(10000,(retryCount) => TimeSpan.FromMilliseconds(250),(e, t, i, c) => OnRetry(request, e, t, i));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < RetryNeededException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(retryAttempt), onRetry :(ex, delay, context, tsk) => { Console.WriteLine($"Retrying exception {ex.ToAsyncString()}"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var _httpRequestPolicy = Policy < MovieDetail >.Handle < Exception >().WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutException = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy httpClientTimeoutExceptionPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is IAsyncPolicy < HttpResponseMessage > httWaitAndpRetryPolicy = Policy.HandleResult < HttpResponseMessage >(r => ! r.IsSuccessStatusCode).WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(retryAttempt));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutRejectedException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(additionalRetries, retryAttempt => TimeSpan.FromSeconds(1));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(RetryCount, retryAttemp => RetryWaitTime,(exception, span, context) => { Trace.TraceError($"{DateTime.Now}: Error Sending Message, retry attempt: {span}, error: {exception}"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, x => TimeSpan.FromSeconds(3));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)), onRetry :(exception, calculatedWaitDuration, attempt, context) => { Console.ForegroundColor = ConsoleColor.Yellow; Console.WriteLine("\tException: " + exception.Message); Console.WriteLine("\tRetry #" + attempt); Console.WriteLine("\t... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Console.ForegroundColor = ConsoleColor.White; if(context.ContainsKey("retry"))(context["retry"] as RetryCounter).Value = attempt; });
Log: predict is null
Log: old usage is var retryPolicy = Policy.HandleResult < HttpResponseMessage >(message => ! message.IsSuccessStatusCode).WaitAndRetryAsync(3, j => TimeSpan.FromSeconds(2),(result, timeSpan, retryCount, context) => { client = new HttpClient(); if(retryCount == 1) { client.BaseAddress = new Uri(creditcardServiceBaseAddress_2 + "1"); LoggingFunction("Retry logic: Start with Alternative 1", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 1 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } else { client.BaseAddress = new Uri(creditcardServiceBaseAddress_3); LoggingFunction("Retry logic: Start with Alternative 2", "Warning    ", "BlackFriday:PaymentMethodsController"); LoggingFunction("Retry logic: Route 2 is not reachable or false URL given...", "Error      ", "BlackFriday:PaymentMethodsController"); } });
Log: predict is null
Log: old usage is AsyncRetryPolicy < HttpResponseMessage > retryPolicy = HttpPolicyExtensions.HandleTransientHttpError().OrResult(r => r.StatusCode == HttpStatusCode.NotFound).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10) },(x, i) => x.Result.Dispose());
Log: predict is null
Log: old usage is var retryAndExitPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < ArgumentException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is var exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: old usage is Policy exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is var exponentialRetryPolicy = Policy.Handle < TException >().WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < StorageException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var retryPolity = Policy.Handle < Exception >().WaitAndRetryAsync(maxTrys, i => timeToWait);
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { log.LogDebug($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < SqlException >().WaitAndRetryAsync(retryCount : retries, sleepDurationProvider : x => TimeSpan.FromSeconds(5), onRetry :(exception, timeSpan, retry, context) => { logger.LogWarning(exception, "[{prefix}] Exception {ExceptionType} with message {Message} detected on attempt {retry} of {retries}", prefix, exception.GetType().Name, exception.Message, retry, retries); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
Log: predict is null
Log: old usage is var retry = Policy.Handle < InvalidOperationException >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2d, retryAttempt)));
Log: predict is null
Log: old usage is var trainRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var addFaceRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var findRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var addRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var matchRetryPolicy = Policy.Handle < FaceAPIException >().WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(16),(ex, timeSpan) => { Console.WriteLine("API key {0} failed. Changing key.", ApiKeys.GetCurrentKey()); ApiKeys.NextKey(); Client = new FaceServiceClient(ApiKeys.GetCurrentKey(), Region); Console.WriteLine("Now using API key {0}.", ApiKeys.GetCurrentKey()); });
Log: predict is null
Log: old usage is var exceptionPolicy = Policy.Handle < HttpRequestException >().Or < WebException >().Or < InvalidOperationException >().OrResult < HttpResponseMessage >(r => httpStatusCodesWorthRetrying.Contains((int) r.StatusCode)).OrResult(r => r.IsSuccessStatusCode == false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var policy = Policy.Handle < WebException >().WaitAndRetryAsync(5, a => TimeSpan.FromMilliseconds(200));
Log: predict is null
Log: old usage is var retryGetSubLanguagesPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var retrySearchSubtitlesFromImdbPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var retryDownloadSubtitleToPathPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(10, retryAttempt => TimeSpan.FromSeconds(300));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var connectPolicy = Policy.HandleResult < bool >(false).WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { Log.Warning("Exception: " + exception.Message); Log.Warning(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms."); Log.Debug(exception, exception.Message); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMinutes(1), onRetry :(exception, calculatedWaitDuration) => { Console.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { System.Diagnostics.Debug.WriteLine("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { Console.WriteLine($"Received {exception.GetType()}{exception.Message}"); Console.WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: predict is null
Log: old usage is var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: predict is null
Log: old usage is var delayed = Policy.Handle < AmqpException >().Or < SocketException >().Or < TimeoutException >().WaitAndRetryAsync(4, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timespan, retries, context) => { WriteLine($"Received {exception.GetType()}{exception.Message}"); WriteLine($"Attempting a connection. Trial after a delay of {timespan.Seconds} seconds"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(2, retrytime => TimeSpan.FromSeconds(Math.Pow(2, retrytime)),(exception, timespan) => { onError.Invoke(exception); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(ex, timeSpan) => { Console.WriteLine($"Exception: {ex.Message}"); Console.WriteLine($"Retrying in {timeSpan.Seconds} seconds"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().Or < TimeoutException >().Or < TimeoutRejectedException >().WaitAndRetryAsync(retryCount : 2, sleepDurationProvider : retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s!"); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(3, retryAttempt => { var waitSeconds = TimeSpan.FromSeconds(Math.Pow(2, retryAttempt - 1)); Console.WriteLine(DateTime.Now.ToString() + "-Retry:[" + retryAttempt + "], wait " + waitSeconds + "s..."); return waitSeconds; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Log4NetLogger.LogDebug(string.Format("{0}下载异常，开始下载重试！\r\n{1}", strFileName, exception.Message)); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < RateLimitExceededException >().WaitAndRetryAsync(5, retry => TimeSpan.FromSeconds(Math.Pow(2, retry)));
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(3, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(20, attempt => TimeSpan.FromMilliseconds(200),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Policy logging: " + exception.Message, Color.Yellow)); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { progress.Report(ProgressWithMessage("Exception: " + exception.Message, Color.Yellow)); progress.Report(ProgressWithMessage(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", Color.Yellow)); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 3, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 20, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(200), onRetry :(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Policy logging: " + exception.Message, ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(6, attempt => TimeSpan.FromSeconds(0.1 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { ConsoleHelper.WriteLineInColor("Exception: " + exception.Message, ConsoleColor.Yellow); ConsoleHelper.WriteLineInColor(" ... automatically delaying for " + calculatedWaitDuration.TotalMilliseconds + "ms.", ConsoleColor.Yellow); retries ++; });
Log: predict is null
Log: old usage is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(retryCount : 5, sleepDurationProvider : attempt => TimeSpan.FromMilliseconds(2000), onRetry :(exception, calculatedWaitDuration) => { Logger.Log($"下载[{downloadUrl}时，发生异常，正在进行重试下载]", Category.Warn, Priority.High); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is Polly.Retry.RetryPolicy < int > politicaWaitAndRetry = Polly.Policy.HandleResult < int >(i => true).WaitAndRetryAsync(new[] { TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(7) },(e, t, i, c) => ReportPollyError(e, t, i, c));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: predict is null
Log: old usage is var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: predict is null
Log: old usage is var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: predict is null
Log: old usage is var policyWrapper = global :: Polly.Policy.Handle < HttpRequestException >().OrResult < ResponseMessage < T > >(r => _httpStatusCodesWorthRetrying.Contains(r.StatusCode)).WaitAndRetryAsync(6, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),(exception, timeSpan, retryCount, context) => { var msg = $"Retry {retryCount}" + $"of {context.OperationKey}" + $"using {context.PolicyKey}, " + $"due to: {exception}."; _logger.Warning(msg); _logger.Information(msg); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures,(exception, timeSpan, retryCount, context) => ManageRetryException(exception, timeSpan, retryCount, context));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(maxRetryAttempts, i => pauseBetweenFailures);
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < Exception >(e => ! cancellationToken.IsCancellationRequested).WaitAndRetryAsync(policyMaxAttempts, attempt => TimeSpan.FromSeconds(retrySeconds),(exception, timeSpan, attempt, context) => { if(attempt == 1) { _log.WriteWarningAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl}. Retry in {retrySeconds} sec.", exception.Message).GetAwaiter().GetResult(); } if(attempt % policyMaxAttempts == 0) { _log.WriteErrorAsync(nameof(ConnectAsync), $"Unable to connect to {_endpointUrl} after {policyMaxAttempts} attempts", exception).GetAwaiter().GetResult(); } });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < ApiConnectionException >().WaitAndRetryAsync(DecorrelatedJitter(50, TimeSpan.FromMilliseconds(250), TimeSpan.FromSeconds(5)), onRetry :(exception, span, count, context) => { Console.WriteLine($"Action failed with error of \"{exception.Message}\". Waiting {span.TotalMilliseconds}ms to retry (#{count})"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.HandleResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: predict is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is IAsyncPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(5, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), onRetry :(exception, retryTimespan) => Log.Logger.Error(exception, $"Retry count {retryTimespan}"));
Log: predict is null
Log: old usage is var retryPolicy = Policy.Handle < HttpRequestException >().WaitAndRetryAsync(2, retryCount => TimeSpan.FromSeconds(2),(exception, timeSpan, retryCount, context) => { _logger.LogWarning($"Call to {url} failed - Retry {retryCount} : TimeSpan {timeSpan} : Ex {exception.Message}"); });
Log: predict is null
Log: old usage is var policy = Policy.Handle < AdalException >(ex => ex.ErrorCode == "temporarily_unavailable").WaitAndRetryAsync(3, a => TimeSpan.FromSeconds(3));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.LogWarning($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is Polly.Retry.RetryPolicy retryPolicy = Policy.Handle < Exception >().WaitAndRetryAsync(3,(retry) => TimeSpan.FromSeconds(2),(ex, ts, attempt, context) => { logger.LogWarning($"An error occurred in attempt number {attempt} to release message {message.MessageId}" + $" in subscription \"{subscription}\": {ex.GetType().Name + " - " + ex.Message}"); });
Log: predict is null
Log: old usage is var retryWhenServiceUnavailable = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.ServiceUnavailable).WaitAndRetryAsync(1, retryAttempt => TimeSpan.FromSeconds(10));
Log: predict is null
Log: old usage is var retryWhenTimeout = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.RequestTimeout).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(5));
Log: predict is null
Log: old usage is var retryWhenThrottling = Policy.HandleResult < HttpResponseMessage >(r => r.StatusCode == HttpStatusCode.TooManyRequests).WaitAndRetryAsync(2, retryAttempt => TimeSpan.FromSeconds(Math.Pow(5, retryAttempt)));
Log: predict is null
Log: old usage is var waitAndRetryPolicy = Policy.Handle < HttpRequestException >().OrResult < HttpResponseMessage >(e => e.StatusCode == HttpStatusCode.ServiceUnavailable || e.StatusCode ==(System.Net.HttpStatusCode) 429 || e.StatusCode ==(System.Net.HttpStatusCode) 403).WaitAndRetryAsync(10, attempt => TimeSpan.FromSeconds(0.25 * Math.Pow(2, attempt)),(exception, calculatedWaitDuration) => { _log.Info($"Computer Vision API server is throttling our requests. Automatically delaying for {calculatedWaitDuration.TotalMilliseconds}ms"); });
Log: predict is null
Log: old usage is Policy policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
Log: predict is var policy = Policy.Handle < Exception >().WaitAndRetryAsync(polly_retry_count, i => polly_pauseBetweenFailures,(exception, timeSpan, context) => { Console.WriteLine("retrying"); });
total correct cases : 2 totalTestCases 2 Successful rate is 1
The successful rate for transforming old usages: 4 / 195
