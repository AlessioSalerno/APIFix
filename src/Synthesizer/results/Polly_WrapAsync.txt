Configuration: 
---- UseAdditionalOutput: False
---- UseAdditionalInput : False
---- OnlyNewUsage       : False
---- GivenExample       : 1
---- UseTypedUsage      : False
---- NewKeyWords        : 
---- OldKeyWords        : 
---- OldUsageThreashold : 0.1
---- NewUsageThreashold : 0.25
load 5 relevant edits!
load 237 old relevant usages
Log: invoke synthesis engine...
Log: the size of unRolledEdits is: 7
Log: add old usage var policy = Policy.WrapAsync(retry, breaker);
Log: add old usage var policy = Policy.WrapAsync(retry, breaker);
Log: add old usage var policy = Policy.WrapAsync(retry, breaker);
Log: add old usage var policy = Policy.WrapAsync(retry, breaker);
Log: add old usage var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
Log: add old usage var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
Log: add old usage var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
Log: add old usage var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
Log: add old usage PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: add old usage PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policy = Policy.WrapAsync(fallBack, delayed);
Log: add old usage var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: add old usage var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: add old usage var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: add old usage PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: add old usage PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: add old usage PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: add old usage PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: add old usage var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
Log: add old usage var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
Log: add old usage var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
Log: add old usage var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
Log: add old usage var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
Log: add old usage var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
Log: add old usage var retryAndBreak = Policy.WrapAsync(retry, breaker);
Log: add old usage var retryAndBreak = Policy.WrapAsync(retry, breaker);
Log: add old usage IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
Log: add old usage IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
Log: ============== Cluster start ==============
- return ((Policy)outerPolicy).WrapAsync(innerPolicy);
----------------
+ return ((AsyncPolicy)outerPolicy).WrapAsync(innerPolicy);

============= Cluster end ==============

Log: ============== Cluster start ==============
((Policy) outerPolicy).WrapAsync(innerPolicy)
----------------
((AsyncPolicy) outerPolicy).WrapAsync(innerPolicy)

============= Cluster end ==============

Log: ============== Cluster start ==============
- return ((Policy<TResult>)outerPolicy).WrapAsync(innerPolicy);
----------------
+ return ((AsyncPolicy<TResult>)outerPolicy).WrapAsync(innerPolicy);

============= Cluster end ==============

Log: ============== Cluster start ==============
((Policy < TResult >) outerPolicy).WrapAsync(innerPolicy)
----------------
((AsyncPolicy < TResult >) outerPolicy).WrapAsync(innerPolicy)

============= Cluster end ==============

Log: ============== Cluster start ==============
PolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
----------------
AsyncPolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);

old usages: var policy = Policy.WrapAsync(retry, breaker);
old usages: var policy = Policy.WrapAsync(retry, breaker);
old usages: var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
old usages: var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
old usages: PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
old usages: var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
old usages: PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
old usages: var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
old usages: var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
old usages: var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
old usages: var retryAndBreak = Policy.WrapAsync(retry, breaker);
old usages: IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
============= Cluster end ==============

Log: Input to synthesize the program:
Log: PolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Log: ---------------------
Log: AsyncPolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Log: old usage is var policy = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
Log: predict is null
Log: old usage is var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
Log: predict is null
Log: old usage is PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: predict is null
Log: old usage is var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is AsyncPolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: old usage is PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: predict is null
Log: old usage is PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is AsyncPolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: old usage is PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: predict is null
Log: old usage is var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
Log: predict is null
Log: old usage is var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
Log: predict is null
Log: old usage is var retryAndBreak = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
Log: predict is null
Log: ============== Cluster start ==============
PolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
----------------
AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);

PolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
----------------
AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);

old usages: var policy = Policy.WrapAsync(retry, breaker);
old usages: var policy = Policy.WrapAsync(retry, breaker);
old usages: var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
old usages: var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
old usages: PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policy = Policy.WrapAsync(fallBack, delayed);
old usages: var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
old usages: var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
old usages: PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
old usages: PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
old usages: var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
old usages: var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
old usages: var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
old usages: var retryAndBreak = Policy.WrapAsync(retry, breaker);
old usages: IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
============= Cluster end ==============

Log: Input to synthesize the program:
Log: PolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Log: ---------------------
Log: AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
Log: predict is AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
Log: output  is AsyncPolicyWrap < ResultPrimitive > wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
Log: ----------------------------------------------------
Log: old usage is var policy = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is var circuitBreakerWrappingTimeout = circuitBreaker.WrapAsync(timeoutPolicy);
Log: predict is null
Log: old usage is var retryWithFallback = fallbackPolicy.WrapAsync(retryPolicy);
Log: predict is null
Log: old usage is PolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: predict is AsyncPolicyWrap < string > policyWrap = Policies.WaitAndRetryPolicy.WrapAsync(Policies.CircuitBreakerPolicy).WrapAsync(Policies.FallbackForCircuitBreaker).WrapAsync(Policies.FallbackForAnyException);
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(fallBack, delayed);
Log: predict is null
Log: old usage is var policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is var policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: predict is null
Log: old usage is var myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is PolicyWrap policyWrap = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: predict is AsyncPolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForCircuitBreaker.WrapAsync(myResilienceStrategy));
Log: old usage is PolicyWrap myResilienceStrategy = Policy.WrapAsync(waitAndRetryPolicy, circuitBreakerPolicy);
Log: predict is null
Log: old usage is PolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: predict is AsyncPolicyWrap < String > policyWrap = fallbackForAnyException.WrapAsync(fallbackForTimeout).WrapAsync(timeoutPolicy).WrapAsync(waitAndRetryPolicy);
Log: old usage is var fallbackAfterCircuitbreaker = fallbackPolicy.WrapAsync(PolicyFactory.CircuitbreakerPolicy());
Log: predict is null
Log: old usage is var policyWrap = Policy.WrapAsync(retryPolicy, timeOutPolicy);
Log: predict is null
Log: old usage is var policy = Policy.WrapAsync(retryPolicy, breakerPolicy);
Log: predict is null
Log: old usage is var retryAndBreak = Policy.WrapAsync(retry, breaker);
Log: predict is null
Log: old usage is IAsyncPolicy policy = Policy.WrapAsync(retryPolicy, bulkheadPolicy);
Log: predict is null
total correct cases : 1 totalTestCases 1 Successful rate is 1
The successful rate for transforming old usages: 4 / 18
